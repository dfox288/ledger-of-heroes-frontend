/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 *
 * Generated from: http://localhost:8080/docs/api.json
 * Generated at: 2025-12-03T05:00:51.849Z
 *
 * To regenerate: npm run types:sync
 */

export interface paths {
    "/v1/lookups/ability-scores": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all ability scores
         * @description Returns a paginated list of the 6 core ability scores in D&D 5e. Each ability score represents
         *     a fundamental character attribute that affects saving throws, skills, attack rolls, and damage.
         *
         *     **The Six Ability Scores:**
         *     - **Strength (STR):** Physical power, melee attacks, climbing, jumping, grappling (Athletics)
         *     - **Dexterity (DEX):** Agility, reflexes, ranged attacks, dodging, balance, stealth (Acrobatics, Sleight of Hand, Stealth)
         *     - **Constitution (CON):** Endurance, health, hit points, concentration saves, resistance to poison/cold
         *     - **Intelligence (INT):** Reasoning, memory, nature, history, investigation (Arcana, History, Investigation, Nature, Religion)
         *     - **Wisdom (WIS):** Awareness, intuition, perception, survival, insight (Animal Handling, Insight, Medicine, Perception, Survival)
         *     - **Charisma (CHA):** Force of personality, persuasion, deception, intimidation (Deception, Intimidation, Performance, Persuasion)
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/ability-scores              # All 6 ability scores
         *     GET /api/v1/lookups/ability-scores?q=strength   # Search by name
         *     GET /api/v1/lookups/ability-scores?q=str        # Search by code
         *     GET /api/v1/lookups/ability-scores?per_page=10  # Custom page size
         *     ```
         *
         *     **Query Parameters:**
         *     - `q` (string): Search by name or code (partial match) - e.g., "str", "strength", "dex"
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - **Character Building:** Determine which ability scores to prioritize based on class (Wizards need INT, Clerics need WIS, Rogues need DEX)
         *     - **Ability Score Checks:** Understand what modifiers apply to skill checks and saving throws
         *     - **Combat Analysis:** Know which abilities affect attack rolls, damage, and AC (DEX for AC, STR for melee attacks)
         */
        get: operations["lookups.ability-scores.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/ability-scores/{abilityScore}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single ability score
         * @description Returns detailed information about a specific ability score including its full name,
         *     code abbreviation, and associated skills. Ability scores can be retrieved by ID, code, or name.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/ability-scores/1              # By ID
         *     GET /api/v1/lookups/ability-scores/STR            # By code
         *     GET /api/v1/lookups/ability-scores/strength       # By slug
         *     GET /api/v1/lookups/ability-scores/Strength       # By name
         *     ```
         *
         *     **Response includes:**
         *     - `id`, `code`, `name`, `slug`: Ability score identification
         *     - `skills`: Associated skills array (e.g., STR has Athletics; DEX has Acrobatics, Sleight of Hand, Stealth)
         */
        get: operations["lookups.ability-scores.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/ability-scores/{abilityScore}/spells": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all spells that require this ability score for saving throws
         * @description Returns a paginated list of spells that require saving throws using this ability score.
         *     Spells are ordered alphabetically by name and include relationships (spell school,
         *     sources, tags). Useful for building spell repertoires, targeting enemy weaknesses,
         *     and understanding spell distribution across saving throw types.
         *
         *     **Basic Examples:**
         *     - Dexterity saves: `GET /api/v1/ability-scores/DEX/spells` (Fireball, Lightning Bolt)
         *     - Wisdom saves: `GET /api/v1/ability-scores/WIS/spells` (Charm Person, Hold Person)
         *     - Constitution saves: `GET /api/v1/ability-scores/CON/spells` (Cloudkill, Stinking Cloud)
         *     - By name (lowercase): `GET /api/v1/ability-scores/dexterity/spells`
         *     - Pagination: `GET /api/v1/ability-scores/STR/spells?per_page=25`
         *
         *     **Common Save Distribution (Approximate):**
         *     - Dexterity (DEX): ~80 spells - Area damage (Fireball, Lightning Bolt), traps, explosions
         *     - Wisdom (WIS): ~60 spells - Mental effects (Charm Person, Fear, Hold Person), illusions
         *     - Constitution (CON): ~50 spells - Poison (Cloudkill), disease, exhaustion, concentration breaks
         *     - Intelligence (INT): ~15 spells - Psychic damage (Phantasmal Force), mental traps, mind control
         *     - Charisma (CHA): ~20 spells - Banishment, extraplanar effects (Banishment, Dispel Evil)
         *     - Strength (STR): ~25 spells - Physical restraint (Entangle, Web), grappling, forced movement
         *
         *     **Targeting Enemy Weaknesses:**
         *     - **Wizards/Sorcerers**: Low STR/CON - Use Entangle, Web, poison spells
         *     - **Fighters/Barbarians**: Low INT/WIS/CHA - Use charm, fear, banishment spells
         *     - **Rogues**: Low STR/WIS - Use grappling, charm, or fear effects
         *     - **Clerics/Druids**: Low DEX/INT - Use area damage (Fireball), psychic attacks
         *     - **Beasts/Constructs**: Low INT/CHA - Use mind-affecting spells (often immune, check first!)
         *     - **Undead**: Low CHA (usually) - Varies widely, check individual monster stats
         *
         *     **Save Effect Types:**
         *     - **Negates**: Save completely negates spell effect (Charm Person, Hold Person)
         *     - **Half Damage**: Save reduces damage by half (Fireball, Lightning Bolt, most evocation)
         *     - **Ends Effect**: Save ends ongoing effect (Fear - save at end of each turn)
         *     - **Reduced Duration**: Save shortens spell duration
         *
         *     **Building Save-Focused Characters:**
         *     - **Evocation Wizard**: Focus on DEX saves (Sculpt Spells lets allies auto-succeed)
         *     - **Enchantment Wizard**: Focus on WIS/CHA saves, boost DC with features
         *     - **Control Wizard**: Mix STR/DEX/WIS saves to target multiple weaknesses
         *     - **Debuff Cleric**: CON/WIS saves for poison, disease, mental effects
         *     - **Spell Selection**: Cover 3+ save types to handle different enemy stat arrays
         *
         *     **Spell DC Optimization:**
         *     - Base DC = 8 + proficiency bonus + spellcasting ability modifier
         *     - Boost DC: +1 items (Rod of the Pact Keeper), class features, spells (Bestow Curse)
         *     - Average DC by level: 13 (level 1), 15 (level 5), 17 (level 11), 19 (level 17)
         *     - Enemy saves scale slower than DC - advantage grows at higher levels
         *
         *     **Tactical Considerations:**
         *     - **Action Economy**: Save-or-suck spells (Hold Person) can eliminate threats instantly
         *     - **Concentration**: Many save spells require concentration - protect it!
         *     - **Legendary Resistance**: High-CR enemies can auto-succeed 3 times - burn through them
         *     - **Magic Resistance**: Some enemies have advantage on saves vs spells - still worth targeting weak saves
         *     - **Repeated Saves**: Some spells allow saves each round (Fear) - less reliable but safer
         *
         *     **Reference Data:**
         *     - 6 ability scores in D&D 5e (STR, DEX, CON, INT, WIS, CHA)
         *     - ~250+ total spells require saving throws (~50% of all spells)
         *     - Most common: DEX (~80 spells), WIS (~60 spells), CON (~50 spells)
         *     - Least common: INT (~15 spells) - exploit this vs low-INT enemies!
         *     - Save DCs range from 13 (level 1) to 19+ (level 17+)
         */
        get: operations["lookups.ability-scores.spells"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/alignments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all alignments
         * @description Returns distinct alignments from the monsters table. These represent the moral and ethical
         *     outlook of creatures in D&D 5e across two axes: Law-Chaos (Lawful to Chaotic) and Good-Evil
         *     (Good to Evil), creating a 3x3 alignment matrix of 9 standard alignments plus special variants.
         *
         *     **Common Examples:**
         *     ```
         *     GET /api/v1/lookups/alignments                # All alignments
         *     GET /api/v1/lookups/alignments?q=good         # Search by keyword
         *     ```
         *
         *     **Standard D&D 5e Alignments (9-axis system):**
         *
         *     **Good Alignments (Primarily benevolent):**
         *     - **Lawful Good:** Order and goodness (Paladins, Lawful Good clerics, noble knights)
         *     - **Neutral Good:** Goodness without rigid structure (Many clerics, some rangers)
         *     - **Chaotic Good:** Goodness with freedom and independence (Rogues, chaotic good monks)
         *
         *     **Neutral Alignments (Balance between law-chaos and good-evil):**
         *     - **Lawful Neutral:** Order without alignment toward good or evil (Monks, Paladins of justice)
         *     - **True Neutral:** Balance between all axes; "I'm just doing my thing" (Druids, some wizards)
         *     - **Chaotic Neutral:** Individualism without moral compass (Unpredictable, selfish creatures)
         *
         *     **Evil Alignments (Primarily malevolent):**
         *     - **Lawful Evil:** Organized, structured malevolence (Devils, tyrants, organized crime)
         *     - **Neutral Evil:** Evil without structure or chaos; purely selfish (Liches, some giants)
         *     - **Chaotic Evil:** Violent, destructive evil (Demons, marauding humanoids, berserkers)
         *
         *     **Special Alignments:**
         *     - **Unaligned:** Constructs, oozes, beasts without sapience (golems, oozes, animals)
         *     - **Any Alignment:** Humanoids that can be any alignment; player choice dependent (e.g., humanoid cultists)
         *     - **Varies:** Individual creatures within the type have different alignments (communities, factions)
         *
         *     **Use Cases:**
         *     - Detect Evil and Good spell targeting (LG, NG, CG vs LE, NE, CE)
         *     - Paladin Divine Sense ability filtering
         *     - Monster filtering in encounter builders by moral/ethical profile
         *     - Character/NPC roleplay guidance and behavior expectations
         *     - Party composition analysis and alignment conflicts
         *
         *     **Query Parameters:**
         *     - `q` (string): Search by name (partial match, case-insensitive)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         */
        get: operations["lookups.alignments.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/armor-types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all armor types
         * @description Returns all distinct armor types worn or possessed by creatures in the D&D 5e database.
         *     Armor types describe the protective equipment a creature wears (leather, plate, chain mail)
         *     or natural protection (scales, hide, exoskeleton). Used for understanding AC calculations
         *     and creature defensive profiles.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/armor-types              # All armor types
         *     GET /api/v1/lookups/armor-types?q=plate      # Search by name
         *     ```
         *
         *     **Armor Categories:**
         *     - **Light Armor:** Leather, Studded leather, Padded, Hierarchy - minimal penalty to Stealth
         *     - **Medium Armor:** Hide, Chain shirt, Scale mail, Breastplate - moderate AC, Stealth disadvantage
         *     - **Heavy Armor:** Chain mail, Plate armor, Ring mail - highest AC, limited mobility
         *     - **Natural Armor:** Dragon scales, Exoskeletons, Tough hide - innate creature protection
         *     - **Shields:** Wooden, Metal, Tower - combine with armor for bonus AC
         *
         *     **AC Calculation Reference:**
         *     - Light: 11 + DEX (Leather), 12 + DEX (Studded leather)
         *     - Medium: 13 + DEX (Hide), 14 + DEX (Scale mail), 14 + DEX (Breastplate)
         *     - Heavy: 16 (Chain mail), 18 (Plate armor) - no DEX bonus
         *     - Natural: Creature-specific (typically 12-15 base)
         *     - Shield: +2 AC when equipped with armor
         *
         *     **Query Parameters:**
         *     - `q` (string): Search by name (partial match)
         *
         *     **Use Cases:**
         *     - **Encounter Building:** Filter monsters by their armor type to balance party composition
         *     - **Spell Selection:** Choose spells effective against common armor types
         *     - **Equipment Planning:** Reference common armor types found in the campaign world
         *     - **Monster Analysis:** Understand how different creatures achieve their AC (armor vs. natural)
         *
         *     **Reference Data:**
         *     Armor types are extracted from ~430 creatures in the Monster Manual and supplemental sources,
         *     providing a comprehensive view of armor protection available to humanoid and monstrous creatures.
         */
        get: operations["lookups.armor-types.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Authenticate user and issue API token
         * @description Validates user credentials and returns a Sanctum personal access token for API authentication.
         *     The token should be included in subsequent requests as a Bearer token in the Authorization header.
         *
         *     **Usage:**
         *     ```
         *     POST /api/v1/auth/login
         *     Content-Type: application/json
         *
         *     {
         *       "email": "user@example.com",
         *       "password": "your-password"
         *     }
         *
         *     Response:
         *     {
         *       "token": "1|abc123...",
         *       "user": {
         *         "id": 1,
         *         "name": "John Doe",
         *         "email": "user@example.com"
         *       }
         *     }
         *     ```
         *
         *     **Using the Token:**
         *     ```
         *     GET /api/v1/protected-endpoint
         *     Authorization: Bearer 1|abc123...
         *     ```
         */
        post: operations["auth.login"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/auth/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Register a new user
         * @description Creates a new user account and returns a Sanctum personal access token for immediate API access.
         *     The token should be included in subsequent requests as a Bearer token in the Authorization header.
         *
         *     **Usage:**
         *     ```
         *     POST /api/v1/auth/register
         *     Content-Type: application/json
         *
         *     {
         *       "name": "John Doe",
         *       "email": "user@example.com",
         *       "password": "password123",
         *       "password_confirmation": "password123"
         *     }
         *
         *     Response (201 Created):
         *     {
         *       "token": "1|abc123...",
         *       "user": {
         *         "id": 1,
         *         "name": "John Doe",
         *         "email": "user@example.com"
         *       }
         *     }
         *     ```
         *
         *     **Validation Requirements:**
         *     - `name`: Required, max 255 characters
         *     - `email`: Required, valid email format, unique in users table
         *     - `password`: Required, minimum 8 characters, must be confirmed
         *     - `password_confirmation`: Required, must match password
         */
        post: operations["auth.register"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Logout and revoke current token
         * @description Revokes the current API token used for authentication. Other tokens for the same user remain valid.
         *     This endpoint requires authentication.
         *
         *     **Usage:**
         *     ```
         *     POST /api/v1/auth/logout
         *     Authorization: Bearer 1|abc123...
         *
         *     Response:
         *     {
         *       "message": "Logged out successfully"
         *     }
         *     ```
         *
         *     **Note:** Only the token used to make this request is revoked. If the user has multiple tokens
         *     (e.g., logged in from multiple devices), those other tokens remain valid.
         */
        post: operations["auth.logout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/backgrounds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all backgrounds
         * @description Returns a paginated list of D&D 5e character backgrounds. Use `?filter=` for filtering and `?q=` for full-text search.
         *
         *     **Common Examples:**
         *     ```
         *     GET /api/v1/backgrounds                                    # All backgrounds (34 total)
         *     GET /api/v1/backgrounds?filter=name = "Acolyte"            # Exact name match
         *     GET /api/v1/backgrounds?filter=tag_slugs IN [criminal]     # Criminal backgrounds
         *     GET /api/v1/backgrounds?filter=source_codes IN [PHB]       # PHB backgrounds only
         *     GET /api/v1/backgrounds?q=noble                            # Full-text search
         *     GET /api/v1/backgrounds?q=noble&filter=source_codes IN [PHB]  # Search + filter combined
         *     GET /api/v1/backgrounds?filter=skill_proficiencies IN [Insight, Religion]  # Specific skills
         *     GET /api/v1/backgrounds?filter=grants_language_choice = true  # Language choices
         *     ```
         *
         *     **Filterable Fields by Data Type:**
         *
         *     **Integer Fields** (Operators: `=`, `!=`, `>`, `>=`, `<`, `<=`):
         *     - `id` (int): Background ID
         *       - Examples: `id = 5`, `id >= 10`
         *
         *     **String Fields** (Operators: `=`, `!=`):
         *     - `name` (string): Background name (e.g., "Acolyte", "Criminal", "Noble", "Soldier")
         *       - Examples: `name = "Acolyte"`, `name != "Soldier"`
         *       - Use Case: Direct filtering by background name
         *     - `slug` (string): URL-friendly identifier (e.g., "acolyte", "criminal", "noble")
         *       - Examples: `slug = "acolyte"`, `slug != "criminal"`
         *
         *     **Boolean Fields** (Operators: `=`, `!=`, `IS NULL`, `EXISTS`):
         *     - `grants_language_choice` (bool): Whether this background grants player-choice languages
         *       - Examples: `grants_language_choice = true`, `grants_language_choice = false`
         *       - Use Case: Find backgrounds that offer language flexibility
         *
         *     **Array Fields** (Operators: `IN`, `NOT IN`, `IS EMPTY`):
         *     - `source_codes` (array): Source book codes (PHB, SCAG, XGE, TCoE, etc.)
         *       - Examples: `source_codes IN [PHB]`, `source_codes IN [PHB, XGE]`, `source_codes NOT IN [UA]`
         *       - Use Case: Filter by campaign-allowed sourcebooks
         *     - `tag_slugs` (array): Descriptive tag slugs (criminal, noble, outlander, sage, soldier, etc.)
         *       - Examples: `tag_slugs IN [criminal]`, `tag_slugs IN [criminal, noble]`
         *       - Use Case: Find backgrounds by archetype
         *     - `skill_proficiencies` (array): Skill names granted by this background
         *       - Examples: `skill_proficiencies IN [Insight]`, `skill_proficiencies IN [Insight, Religion]`
         *       - Use Case: Fill skill gaps in party composition (e.g., "Need someone with Insight")
         *     - `tool_proficiency_types` (array): Tool proficiency type names
         *       - Examples: `tool_proficiency_types IN [Thieves' Tools]`
         *       - Use Case: Find backgrounds for rogues/thieves
         *
         *     **Complex Filter Examples:**
         *     - Criminal backgrounds with Insight: `?filter=tag_slugs IN [criminal] AND skill_proficiencies IN [Insight]`
         *     - Backgrounds with language choices from PHB: `?filter=grants_language_choice = true AND source_codes IN [PHB]`
         *     - Non-PHB backgrounds: `?filter=source_codes NOT IN [PHB]`
         *     - Multiple skill requirements: `?filter=skill_proficiencies IN [Insight, Religion] AND source_codes IN [PHB]`
         *     - Search + filter: `?q=noble&filter=grants_language_choice = true`
         *
         *     **Use Cases:**
         *     - **Character Creation:** Find backgrounds that grant specific skill proficiencies needed for your build
         *     - **Party Optimization:** Identify backgrounds that fill skill gaps (e.g., party needs Insight & Religion)
         *     - **Roleplay Choices:** Filter by tags to find backgrounds matching character concept (criminal, noble, etc.)
         *     - **Source Restrictions:** Limit to PHB-only for Adventurers League or homebrew campaigns
         *     - **Language Flexibility:** Find backgrounds granting language choices for multilingual characters
         *
         *     **Operator Reference:**
         *     See `docs/MEILISEARCH-FILTER-OPERATORS.md` for comprehensive operator documentation.
         *
         *     **Query Parameters:**
         *     - `q` (string): Full-text search (searches name, description, traits)
         *     - `filter` (string): Meilisearch filter expression
         *     - `sort_by` (string): name, created_at, updated_at (default: name)
         *     - `sort_direction` (string): asc, desc (default: asc)
         *     - `per_page` (int): 1-100 (default: 15)
         *     - `page` (int): Page number (default: 1)
         */
        get: operations["backgrounds.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/backgrounds/{background}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single background
         * @description Returns detailed information about a specific background including proficiencies,
         *     traits with random tables (personality, ideals, bonds, flaws), languages, and sources.
         *     Supports selective relationship loading via the 'include' parameter.
         */
        get: operations["backgrounds.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/characters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all characters
         * @description Returns a paginated list of characters. Use for displaying character lists in a character selection screen.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/characters               # All characters
         *     GET /api/v1/characters?per_page=10   # Custom page size
         *     ```
         */
        get: operations["characters.index"];
        put?: never;
        /**
         * Create a new character
         * @description Creates a new character with the provided data. Supports wizard-style creation where only name is required,
         *     and other fields can be filled in later via PATCH updates.
         *
         *     **Examples:**
         *     ```
         *     POST /api/v1/characters {"name": "Gandalf"}                                    # Draft character
         *     POST /api/v1/characters {"name": "Legolas", "race_id": 1, "class_id": 2}      # With race/class
         *     POST /api/v1/characters {"name": "Conan", "strength": 18, "constitution": 16} # With ability scores
         *     ```
         *
         *     **Validation:**
         *     - `name` (required): Character name
         *     - `race_id`, `class_id`, `background_id`: Must exist if provided
         *     - Ability scores (STR, DEX, etc.): Must be 3-20 if provided
         */
        post: operations["characters.store"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/characters/{character}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a character
         * @description Returns detailed character information including ability scores, modifiers, and validation status.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/characters/1
         *     ```
         *
         *     **Response includes:**
         *     - Basic info: name, level, XP
         *     - Ability scores (STR, DEX, CON, INT, WIS, CHA)
         *     - Calculated modifiers
         *     - Proficiency bonus
         *     - Relationships: race, class, background
         *     - Validation status: is_complete, missing fields
         */
        get: operations["characters.show"];
        /**
         * Update a character
         * @description Updates character fields. Supports partial updates (PATCH semantics).
         *
         *     **Examples:**
         *     ```
         *     PATCH /api/v1/characters/1 {"name": "NewName"}
         *     PATCH /api/v1/characters/1 {"race_id": 5}
         *     PATCH /api/v1/characters/1 {"strength": 18, "dexterity": 14}
         *     ```
         *
         *     **Validation:**
         *     - Ability scores must be 3-20
         *     - IDs (race_id, class_id, background_id) must exist
         */
        put: operations["characters.update"];
        post?: never;
        /**
         * Delete a character
         * @description Permanently deletes a character and all associated data (spells, proficiencies, features, equipment).
         *
         *     **Examples:**
         *     ```
         *     DELETE /api/v1/characters/1
         *     ```
         */
        delete: operations["characters.destroy"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/characters/{character}/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get computed stats for a character
         * @description Returns all computed statistics for the character, including ability modifiers,
         *     proficiency bonus, saving throws, spell save DC, and spell slots.
         *
         *     Results are cached for 15 minutes for performance. Cache is invalidated
         *     when the character is updated.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/characters/1/stats
         *     ```
         *
         *     **Response includes:**
         *     - Ability scores with modifiers
         *     - Proficiency bonus
         *     - Saving throw modifiers
         *     - Armor class and hit points
         *     - Spellcasting: ability, spell save DC, attack bonus
         *     - Spell slots by level
         *     - Preparation limit and count
         */
        get: operations["characters.stats"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/characters/{character}/equipment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all equipment for a character */
        get: operations["characters.equipment.index"];
        put?: never;
        /** Add item to character inventory */
        post: operations["characters.equipment.store"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/characters/{character}/equipment/{equipment}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Remove item from inventory */
        delete: operations["characters.equipment.destroy"];
        options?: never;
        head?: never;
        /** Update equipment (equip/unequip, change quantity) */
        patch: operations["characters.equipment.update"];
        trace?: never;
    };
    "/v1/characters/{character}/level-up": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Level up a character
         * @description Increases character level by 1, grants HP, class features, and updates spell slots.
         */
        post: operations["characters.level-up"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/characters/{character}/spells": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all spells known by the character
         * @description Returns spells the character has learned, including preparation status.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/characters/1/spells
         *     ```
         */
        get: operations["characters.spells.index"];
        put?: never;
        /**
         * Learn a new spell
         * @description Adds a spell to the character's known spells.
         *
         *     **Examples:**
         *     ```
         *     POST /api/v1/characters/1/spells {"spell_id": 123}
         *     ```
         *
         *     **Validation:**
         *     - Spell must be on the character's class spell list
         *     - Spell level must be accessible at character's level
         *     - Spell must not already be known
         */
        post: operations["characters.spells.store"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/characters/{character}/available-spells": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List spells available for the character to learn
         * @description Returns spells on the character's class spell list that they haven't learned yet.
         *     Optionally filter by maximum spell level.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/characters/1/available-spells
         *     GET /api/v1/characters/1/available-spells?max_level=3
         *     ```
         */
        get: operations["characters.spells.available"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/characters/{character}/spells/{spell}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Remove a spell from the character's known spells
         * @description **Examples:**
         *     ```
         *     DELETE /api/v1/characters/1/spells/123
         *     ```
         */
        delete: operations["characters.spells.destroy"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/characters/{character}/spells/{spell}/prepare": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Prepare a spell for casting
         * @description Changes a spell's status from 'known' to 'prepared'.
         *     Cantrips cannot be prepared (they're always ready).
         *
         *     **Examples:**
         *     ```
         *     PATCH /api/v1/characters/1/spells/123/prepare
         *     ```
         */
        patch: operations["characters.spells.prepare"];
        trace?: never;
    };
    "/v1/characters/{character}/spells/{spell}/unprepare": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Unprepare a spell
         * @description Changes a spell's status from 'prepared' to 'known'.
         *     Always-prepared spells (from domain, etc.) cannot be unprepared.
         *
         *     **Examples:**
         *     ```
         *     PATCH /api/v1/characters/1/spells/123/unprepare
         *     ```
         */
        patch: operations["characters.spells.unprepare"];
        trace?: never;
    };
    "/v1/characters/{character}/spell-slots": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get spell slot information for the character
         * @description Returns available spell slots by level and the preparation limit.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/characters/1/spell-slots
         *     ```
         */
        get: operations["characters.spell-slots"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/classes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Display a paginated, searchable, and filterable list of character classes
         * @description ## Common Examples
         *
         *     ```bash
         *     # All base classes (no subclasses)
         *     GET /api/v1/classes?filter=is_base_class = true
         *
         *     # Full spellcasters (9th level spells)
         *     GET /api/v1/classes?filter=max_spell_level = 9
         *
         *     # Classes with heavy armor proficiency (tanky classes)
         *     GET /api/v1/classes?filter=armor_proficiencies IN ["Heavy Armor"]
         *
         *     # Wisdom-based spellcasters (Cleric, Druid, Ranger)
         *     GET /api/v1/classes?filter=spellcasting_ability = "WIS"
         *
         *     # Classes with Dexterity save proficiency (evasion)
         *     GET /api/v1/classes?filter=saving_throw_proficiencies IN ["DEX"]
         *
         *     # Tanky spellcasters (heavy armor + spellcasting)
         *     GET /api/v1/classes?filter=is_spellcaster = true AND armor_proficiencies IN ["Heavy Armor"]
         *
         *     # High hit die classes (d10 or d12) for durability
         *     GET /api/v1/classes?filter=hit_die >= 10
         *     ```
         *
         *     ## Filterable Fields by Data Type
         *
         *     ### Integer Fields
         *
         *     **id** (`integer`)
         *     - Value range: 1 to 131
         *     - Operators: `=`, `!=`, `<`, `<=`, `>`, `>=`, `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=id = 1` (Fighter base class)
         *       - `filter=id IN [1, 2, 3]` (Fighter, Wizard, Cleric)
         *     - Use case: Direct lookups when ID is known
         *
         *     **hit_die** (`integer`)
         *     - Value range: 6, 8, 10, 12 (d6, d8, d10, d12)
         *     - Operators: `=`, `!=`, `<`, `<=`, `>`, `>=`, `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=hit_die = 12` (Barbarian - highest HP)
         *       - `filter=hit_die >= 10` (d10/d12 classes for durability)
         *       - `filter=hit_die = 6` (Wizard, Sorcerer - low HP)
         *     - Use case: Character optimization for survivability
         *
         *     **spell_count** (`integer`)
         *     - Value range: 0 to 477 (number of spells available to this class)
         *     - Operators: `=`, `!=`, `<`, `<=`, `>`, `>=`, `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=spell_count > 100` (classes with large spell lists)
         *       - `filter=spell_count = 0` (non-spellcasting classes)
         *     - Use case: Finding classes with extensive spell options
         *
         *     **max_spell_level** (`integer`)
         *     - Value range: 0 to 9 (highest spell level available)
         *     - Operators: `=`, `!=`, `<`, `<=`, `>`, `>=`, `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=max_spell_level = 9` (full casters: Wizard, Cleric, Bard, Druid, Sorcerer, Warlock)
         *       - `filter=max_spell_level = 5` (half casters: Paladin, Ranger)
         *       - `filter=max_spell_level IN [0, 1, 2, 3, 4]` (non-casters and third casters)
         *     - Use case: Distinguishing full/half/third casters for multiclass planning
         *
         *     ### String Fields
         *
         *     **slug** (`string`)
         *     - Value examples: "fighter", "champion", "eldritch-knight", "wizard"
         *     - Operators: `=`, `!=`, `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=slug = "fighter"` (Fighter base class)
         *       - `filter=slug IN ["champion", "battle-master", "eldritch-knight"]` (Fighter subclasses)
         *     - Use case: Human-readable queries and URL-friendly lookups
         *
         *     **archetype** (`string`)
         *     - Value examples: "Martial Archetype", "Divine Domain", "Arcane Tradition", null (for subclasses)
         *     - Operators: `=`, `!=`, `IN`, `NOT IN`, `IS NULL`, `IS NOT NULL`
         *     - Examples:
         *       - `filter=archetype = "Martial Archetype"` (Fighter base class)
         *       - `filter=archetype IS NOT NULL` (all base classes with archetype names)
         *       - `filter=archetype IS NULL` (subclasses - they inherit from parent)
         *     - Use case: Display "Choose your Martial Archetype at level 3" in UI
         *
         *     **primary_ability** (`string`)
         *     - Value range: "STR", "DEX", "CON", "INT", "WIS", "CHA"
         *     - Operators: `=`, `!=`, `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=primary_ability = "STR"` (Barbarian, Fighter, Paladin)
         *       - `filter=primary_ability IN ["INT", "WIS", "CHA"]` (mental ability classes)
         *     - Use case: Finding classes that benefit from specific ability scores
         *
         *     **spellcasting_ability** (`string`)
         *     - Value range: "INT", "WIS", "CHA", null (for non-spellcasters)
         *     - Operators: `=`, `!=`, `IN`, `NOT IN`, `IS NULL`, `IS NOT NULL`
         *     - Examples:
         *       - `filter=spellcasting_ability = "INT"` (Wizard, Artificer)
         *       - `filter=spellcasting_ability = "WIS"` (Cleric, Druid, Ranger)
         *       - `filter=spellcasting_ability = "CHA"` (Bard, Sorcerer, Warlock, Paladin)
         *       - `filter=spellcasting_ability IS NULL` (non-spellcasters)
         *     - Use case: Multiclass optimization - matching spellcasting abilities to avoid MAD (Multiple Ability Dependency)
         *
         *     **parent_class_name** (`string`)
         *     - Value examples: "Fighter", "Wizard", "Cleric", null (for base classes)
         *     - Operators: `=`, `!=`, `IN`, `NOT IN`, `IS NULL`, `IS NOT NULL`
         *     - Examples:
         *       - `filter=parent_class_name = "Fighter"` (all Fighter subclasses)
         *       - `filter=parent_class_name IS NULL` (base classes only)
         *     - Use case: Finding subclasses for a specific base class
         *
         *     ### Boolean Fields
         *
         *     **is_base_class** (`boolean`)
         *     - Value range: `true` (12 base classes), `false` (119 subclasses)
         *     - Operators: `=`, `!=`
         *     - Examples:
         *       - `filter=is_base_class = true` (Barbarian, Bard, Cleric, Druid, Fighter, Monk, Paladin, Ranger, Rogue, Sorcerer, Warlock, Wizard)
         *       - `filter=is_base_class = false` (all subclasses)
         *     - Use case: Character creation - choose base class first, then filter subclasses
         *
         *     **is_subclass** (`boolean`)
         *     - Value range: `true` (119 subclasses), `false` (12 base classes)
         *     - Operators: `=`, `!=`
         *     - Examples:
         *       - `filter=is_subclass = true` (all subclasses)
         *       - `filter=is_subclass = false` (base classes)
         *     - Use case: Inverse of `is_base_class` - useful for API consistency
         *
         *     **has_spells** (`boolean`)
         *     - Value range: `true` (class has spell list), `false` (no spell list)
         *     - Operators: `=`, `!=`
         *     - Examples:
         *       - `filter=has_spells = true` (spellcasting classes and subclasses)
         *       - `filter=has_spells = false` (martial classes without spells)
         *     - Use case: Quick filter for classes with magical abilities
         *
         *     **is_spellcaster** (`boolean`)
         *     - Value range: `true` (class/subclass gains spellcasting feature), `false` (no spellcasting)
         *     - Operators: `=`, `!=`
         *     - Examples:
         *       - `filter=is_spellcaster = true` (full/half/third casters)
         *       - `filter=is_spellcaster = false` (pure martial classes)
         *     - Use case: Distinguishing classes with Spellcasting feature vs spell-like abilities
         *
         *     **has_optional_features** (`boolean`)
         *     - Value range: `true` (class has invocations, maneuvers, etc.), `false` (no optional features)
         *     - Operators: `=`, `!=`
         *     - Examples:
         *       - `filter=has_optional_features = true` (Warlock, Fighter, Sorcerer, Monk)
         *       - `filter=has_optional_features = false` (classes without customization options)
         *     - Use case: Finding classes with additional character customization choices
         *
         *     ### Integer Fields (Optional Features)
         *
         *     **optional_feature_count** (`integer`)
         *     - Value range: 0 to 54 (number of optional features available)
         *     - Operators: `=`, `!=`, `<`, `<=`, `>`, `>=`, `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=optional_feature_count > 0` (classes with optional features)
         *       - `filter=optional_feature_count >= 10` (classes with many customization options)
         *     - Use case: Finding classes with extensive customization options
         *
         *     ### Array Fields
         *
         *     **source_codes** (`array of strings`)
         *     - Value examples: ["PHB"], ["XGTE"], ["TCOE"], ["PHB", "XGTE"]
         *     - Operators: `IN`, `NOT IN` (checks if ANY value in field matches ANY value in filter)
         *     - Examples:
         *       - `filter=source_codes IN ["PHB"]` (Player's Handbook classes)
         *       - `filter=source_codes IN ["XGTE", "TCOE"]` (Xanathar's or Tasha's content)
         *     - Use case: Filtering by allowed sourcebooks for campaigns
         *
         *     **tag_slugs** (`array of strings`)
         *     - Value examples: ["spellcasting"], ["martial"], ["stealth"], ["healing"]
         *     - Operators: `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=tag_slugs IN ["spellcasting"]` (classes with spellcasting tag)
         *       - `filter=tag_slugs IN ["martial"]` (weapon-focused classes)
         *     - Use case: Thematic filtering for character concepts
         *
         *     **saving_throw_proficiencies** (`array of strings`)
         *     - Value range: ["STR"], ["DEX"], ["CON"], ["INT"], ["WIS"], ["CHA"] (always 2 per class)
         *     - Operators: `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=saving_throw_proficiencies IN ["DEX"]` (Rogue, Monk, Ranger - evasion synergy)
         *       - `filter=saving_throw_proficiencies IN ["WIS"]` (Cleric, Druid, Paladin, Ranger, Monk - mind control resistance)
         *       - `filter=saving_throw_proficiencies IN ["CON"]` (Fighter, Barbarian, Sorcerer - concentration checks)
         *     - Use case: **Critical for multiclass planning** - you gain new saving throw proficiencies ONLY from your first class
         *
         *     **armor_proficiencies** (`array of strings`)
         *     - Value examples: ["Light Armor"], ["Medium Armor"], ["Heavy Armor"], ["Shields"], specific armor types
         *     - Operators: `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=armor_proficiencies IN ["Heavy Armor"]` (Cleric, Fighter, Paladin - AC optimization)
         *       - `filter=armor_proficiencies IN ["Shields"]` (classes that can use shields)
         *       - `filter=armor_proficiencies IN ["Light Armor"]` (Rogue, Ranger, Bard - DEX-based AC)
         *     - Use case: **Multiclass AC planning** - determines maximum AC without multiclassing
         *
         *     **weapon_proficiencies** (`array of strings`)
         *     - Value examples: ["Simple Weapons"], ["Martial Weapons"], specific weapon names
         *     - Operators: `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=weapon_proficiencies IN ["Martial Weapons"]` (Fighter, Paladin, Ranger, Barbarian)
         *       - `filter=weapon_proficiencies IN ["Simple Weapons"]` (most classes)
         *     - Use case: **Weapon optimization** - finding classes that can use specific weapons
         *
         *     **tool_proficiencies** (`array of strings`)
         *     - Value examples: ["Thieves' Tools"], ["Smith's Tools"], ["Alchemist's Supplies"]
         *     - Operators: `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=tool_proficiencies IN ["Thieves' Tools"]` (Rogue, some Artificer subclasses)
         *       - `filter=tool_proficiencies IN ["Alchemist's Supplies"]` (Artificer)
         *     - Use case: Finding classes with specific tool proficiencies for crafting/utility
         *
         *     **skill_proficiencies** (`array of strings`)
         *     - Value examples: ["Stealth"], ["Perception"], ["Insight"], ["Athletics"]
         *     - Operators: `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=skill_proficiencies IN ["Stealth"]` (Rogue, Ranger - sneaky classes)
         *       - `filter=skill_proficiencies IN ["Perception"]` (Ranger, Druid - wilderness awareness)
         *     - Note: This field contains **available** skill choices, not guaranteed proficiencies
         *     - Use case: Finding classes with access to specific skills
         *
         *     **optional_feature_types** (`array of strings`)
         *     - Value examples: ["eldritch_invocation"], ["maneuver"], ["metamagic"], ["elemental_discipline"]
         *     - Operators: `IN`, `NOT IN`
         *     - Examples:
         *       - `filter=optional_feature_types IN ["eldritch_invocation"]` (Warlock)
         *       - `filter=optional_feature_types IN ["maneuver"]` (Fighter Battle Master)
         *       - `filter=optional_feature_types IN ["metamagic"]` (Sorcerer)
         *     - Use case: Finding classes with specific customization mechanics
         *
         *     ## Complex Filter Examples
         *
         *     ```bash
         *     # Tanky spellcasters (heavy armor + full casting)
         *     GET /api/v1/classes?filter=armor_proficiencies IN ["Heavy Armor"] AND max_spell_level = 9
         *
         *     # Wisdom-based full casters with Wisdom save proficiency
         *     GET /api/v1/classes?filter=spellcasting_ability = "WIS" AND max_spell_level = 9 AND saving_throw_proficiencies IN ["WIS"]
         *
         *     # Durable half-casters (d10 hit die + 5th level spells)
         *     GET /api/v1/classes?filter=hit_die = 10 AND max_spell_level = 5
         *
         *     # PHB base classes with heavy armor proficiency
         *     GET /api/v1/classes?filter=source_codes IN ["PHB"] AND is_base_class = true AND armor_proficiencies IN ["Heavy Armor"]
         *
         *     # Charisma-based spellcasters (multiclass synergy)
         *     GET /api/v1/classes?filter=spellcasting_ability = "CHA" AND max_spell_level >= 5
         *
         *     # Non-spellcasters with Dexterity save proficiency (pure martials with evasion)
         *     GET /api/v1/classes?filter=is_spellcaster = false AND saving_throw_proficiencies IN ["DEX"]
         *
         *     # Classes with martial weapons and spellcasting (gish classes)
         *     GET /api/v1/classes?filter=weapon_proficiencies IN ["Martial Weapons"] AND is_spellcaster = true
         *
         *     # Low-HP full casters (d6 hit die, 9th level spells)
         *     GET /api/v1/classes?filter=hit_die = 6 AND max_spell_level = 9
         *
         *     # Base classes with Constitution save proficiency (concentration casters)
         *     GET /api/v1/classes?filter=is_base_class = true AND saving_throw_proficiencies IN ["CON"]
         *
         *     # Tasha's Cauldron subclasses that are spellcasters
         *     GET /api/v1/classes?filter=source_codes IN ["TCOE"] AND is_subclass = true AND is_spellcaster = true
         *
         *     # Classes with Eldritch Invocations (Warlock customization)
         *     GET /api/v1/classes?filter=optional_feature_types IN ["eldritch_invocation"]
         *
         *     # Classes with many optional feature choices
         *     GET /api/v1/classes?filter=optional_feature_count >= 10
         *
         *     # Martial classes with combat maneuvers
         *     GET /api/v1/classes?filter=optional_feature_types IN ["maneuver"] AND is_spellcaster = false
         *     ```
         *
         *     ## Use Cases
         *
         *     **Character Creation**
         *     - Find base classes by primary ability: `filter=is_base_class = true AND primary_ability = "CHA"`
         *     - Compare hit dice for survivability: `filter=hit_die >= 10`
         *
         *     **Multiclass Planning**
         *     - Find compatible spellcasting abilities: `filter=spellcasting_ability = "CHA" AND max_spell_level >= 5`
         *     - Identify armor proficiency gaps: `filter=armor_proficiencies IN ["Heavy Armor"] AND is_base_class = true`
         *     - Save proficiency optimization: `filter=saving_throw_proficiencies IN ["WIS", "DEX"]` (best saves)
         *
         *     **Campaign Restrictions**
         *     - Filter by allowed sourcebooks: `filter=source_codes IN ["PHB", "XGTE"]`
         *     - Exclude subclasses: `filter=is_base_class = true`
         *
         *     **Build Optimization**
         *     - Find tanky spellcasters: `filter=armor_proficiencies IN ["Heavy Armor"] AND is_spellcaster = true`
         *     - Identify gish classes (melee + magic): `filter=weapon_proficiencies IN ["Martial Weapons"] AND is_spellcaster = true`
         *     - High-HP casters: `filter=hit_die >= 8 AND max_spell_level = 9`
         *
         *     **Spell List Analysis**
         *     - Classes with large spell pools: `filter=spell_count > 100`
         *     - Full casters only: `filter=max_spell_level = 9`
         *
         *     **Thematic Search**
         *     - Find classes with specific tags: `filter=tag_slugs IN ["healing", "support"]`
         *     - Stealth-capable classes: `filter=skill_proficiencies IN ["Stealth"]`
         *
         *     **Optional Features / Customization**
         *     - Find classes with invocations: `filter=optional_feature_types IN ["eldritch_invocation"]`
         *     - Martial classes with maneuvers: `filter=optional_feature_types IN ["maneuver"]`
         *     - Classes with high customization: `filter=optional_feature_count >= 10`
         *     - Sorcerer metamagic: `filter=optional_feature_types IN ["metamagic"]`
         *
         *     ## Filter Operators
         *
         *     For complete operator documentation and syntax, see:
         *     https://www.meilisearch.com/docs/reference/api/search#filter
         */
        get: operations["classes.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/classes/{class}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single class
         * @description Returns detailed information about a specific class or subclass including parent class,
         *     subclasses, proficiencies, traits, features, level progression, spell slot tables,
         *     and counters. Supports selective relationship loading via the 'include' parameter.
         *
         *     ## Response Structure
         *
         *     The response separates data into three categories for API clarity:
         *     - **Base fields** - Core entity data (with inheritance resolved for subclasses)
         *     - **inherited_data** - Pre-resolved parent class data (subclasses only)
         *     - **computed** - Aggregated/calculated data for display optimization
         *
         *     ## Field Inheritance (Automatic)
         *
         *     D&D 5e subclasses inherit certain properties from their parent class. The API
         *     automatically resolves this inheritance in base fields:
         *
         *     - **hit_die**: Subclasses show inherited value (Death Domain  8 from Cleric)
         *     - **spellcasting_ability**: Subclasses show inherited value (Death Domain  Wisdom from Cleric)
         *
         *     You never see raw database values (hit_die: 0 or spellcasting_ability: null) for subclasses.
         *     The effective values are always returned.
         *
         *     ## Computed Object (Display-Ready Data)
         *
         *     The `computed` object contains pre-computed fields to reduce frontend logic.
         *     Only included on show endpoint responses.
         *
         *     **computed.hit_points** - Pre-calculated D&D 5e hit point formulas:
         *     ```json
         *     {
         *       "hit_die": "d10",
         *       "hit_die_numeric": 10,
         *       "first_level": {"value": 10, "description": "10 + your Constitution modifier"},
         *       "higher_levels": {"roll": "1d10", "average": 6, "description": "1d10 (or 6) + your Constitution modifier per fighter level after 1st"}
         *     }
         *     ```
         *
         *     **computed.spell_slot_summary** - Spellcasting overview for UI column visibility:
         *     ```json
         *     {
         *       "has_spell_slots": true,
         *       "max_spell_level": 9,
         *       "available_levels": [1, 2, 3, 4, 5, 6, 7, 8, 9],
         *       "has_cantrips": true,
         *       "caster_type": "full"
         *     }
         *     ```
         *     - `caster_type`: "full" (9th level), "half" (5th level), "third" (4th level), or null (non-caster)
         *
         *     **computed.section_counts** - Relationship counts for lazy-loading accordion labels:
         *     ```json
         *     {
         *       "features": 34,
         *       "proficiencies": 12,
         *       "traits": 8,
         *       "subclasses": 7,
         *       "spells": 89,
         *       "counters": 3,
         *       "optional_features": 0
         *     }
         *     ```
         *
         *     **computed.progression_table** - Complete 20-level progression table:
         *     ```json
         *     {
         *       "columns": [
         *         {"key": "level", "label": "Level", "type": "integer"},
         *         {"key": "proficiency_bonus", "label": "Proficiency Bonus", "type": "bonus"},
         *         {"key": "features", "label": "Features", "type": "string"},
         *         {"key": "sneak_attack", "label": "Sneak Attack", "type": "dice"}
         *       ],
         *       "rows": [
         *         {"level": 1, "proficiency_bonus": "+2", "features": "Expertise, Sneak Attack", "sneak_attack": "1d6"},
         *         {"level": 2, "proficiency_bonus": "+2", "features": "Cunning Action", "sneak_attack": "1d6"}
         *       ]
         *     }
         *     ```
         *
         *     **Column Sources:**
         *     - **Feature data tables**: Parsed from feature descriptions (Monk's Martial Arts: 1d41d10)
         *     - **Roll elements**: From XML `<roll>` data (Rogue's Sneak Attack: 1d610d6)
         *     - **Synthetic data**: Hardcoded for prose-only progressions (Barbarian's Rage Damage: +2+4)
         *     - **Counters**: Class counter values (Ki Points, Rage uses)
         *     - **Spell slots**: Cantrips known, 1st-9th level slots for casters
         *
         *     Values are interpolated (sparse data filled in for all 20 levels).
         *     Also available via dedicated endpoint: `GET /classes/{slug}/progression`
         *
         *     ## Inherited Data (Subclasses Only)
         *
         *     **inherited_data** - Pre-resolved parent class data for subclasses:
         *     ```json
         *     {
         *       "hit_die": 10,
         *       "hit_points": {...},
         *       "counters": [...],
         *       "traits": [...],
         *       "level_progression": [...],
         *       "equipment": [...],
         *       "proficiencies": [...],
         *       "spell_slot_summary": {...}
         *     }
         *     ```
         *     - Eliminates frontend inheritance resolution logic
         *     - Only present for subclasses (is_base_class = false)
         *     - Contains essential data from parent class that subclasses need
         *
         *     ## Feature Inheritance for Subclasses
         *
         *     - By default, subclasses return ALL features (inherited base class features + subclass-specific features)
         *     - Use `?include_base_features=false` to return only subclass-specific features
         *     - Base classes are unaffected by this parameter
         *
         *     ## Feature Choice Options (Nested Features)
         *
         *     Features that offer choices (like Fighting Style) have their options nested:
         *
         *     ```json
         *     {
         *       "feature_name": "Fighting Style",
         *       "is_choice_option": false,
         *       "parent_feature_id": null,
         *       "choice_options": [
         *         {"feature_name": "Fighting Style: Archery", "is_choice_option": true, "parent_feature_id": 397},
         *         {"feature_name": "Fighting Style: Defense", "is_choice_option": true, "parent_feature_id": 397}
         *       ]
         *     }
         *     ```
         *
         *     - **is_choice_option**: `true` if this feature is a choice under a parent (player picks one)
         *     - **parent_feature_id**: ID of the parent feature (null for top-level features)
         *     - **choice_options**: Nested array of child features (only present when loaded)
         *
         *     This allows frontends to:
         *     - Display choice options in a collapsible/grouped UI
         *     - Filter out choice options from main feature lists (check `is_choice_option`)
         *     - Show accurate feature counts (exclude choice options)
         *
         *     ## Examples
         *
         *     ```bash
         *     # Get Fighter with computed object
         *     GET /api/v1/classes/fighter
         *
         *     # Get Arcane Trickster (subclass) with inherited_data from Rogue parent
         *     GET /api/v1/classes/rogue-arcane-trickster
         *
         *     # Get only subclass-specific features (not inherited)
         *     GET /api/v1/classes/rogue-arcane-trickster?include_base_features=false
         *     ```
         *
         *     ## Note on Index vs Show
         *
         *     The `computed` object is **only included on show endpoint** for performance.
         *     Index endpoint returns base fields and relationships without computed data.
         */
        get: operations["classes.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/classes/{class}/spells": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get spells available to a class
         * @description Returns a paginated list of spells available to a specific class. Supports the same
         *     filtering options as the main spell list (level, school, concentration, ritual).
         *     Useful for building spell lists for spellcasting classes.
         */
        get: operations["classes.spells"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/classes/{class}/progression": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the progression table for a class
         * @description Returns a pre-computed progression table showing level-by-level advancement
         *     including proficiency bonus, features gained, class-specific counters (like
         *     Sneak Attack dice, Ki Points, Rage uses), and spell slots if applicable.
         *
         *     This endpoint is useful for lazy-loading the progression table separately
         *     from the main class detail response.
         *
         *     ## Response Structure
         *
         *     **columns** - Dynamic column definitions based on class features:
         *     - Always includes: level, proficiency_bonus, features
         *     - Feature data tables: martial_arts (Monk), etc. - parsed from feature descriptions
         *     - Roll element tables: sneak_attack (Rogue) - from XML `<roll>` data
         *     - Synthetic progressions: rage_damage (Barbarian) - hardcoded from PHB prose
         *     - Counter columns: ki (Monk), rage (Barbarian), etc. - from class counters
         *     - Spell slot columns: cantrips_known, spell_slots_1st through spell_slots_9th (for casters)
         *
         *     **rows** - 20 rows, one per level, with all column values pre-computed:
         *     - Values interpolated (sparse data filled in for all levels)
         *     - Dice values: "1d4", "1d6", "2d6", etc.
         *     - Bonus values: "+2", "+3", etc.
         *     - Proficiency bonus formatted as "+X"
         *     - Features joined with commas
         *
         *     ## Example Response
         *
         *     ```json
         *     {
         *       "data": {
         *         "columns": [
         *           {"key": "level", "label": "Level", "type": "integer"},
         *           {"key": "proficiency_bonus", "label": "Proficiency Bonus", "type": "bonus"},
         *           {"key": "features", "label": "Features", "type": "string"},
         *           {"key": "ki_points", "label": "Ki Points", "type": "integer"}
         *         ],
         *         "rows": [
         *           {"level": 1, "proficiency_bonus": "+2", "features": "Unarmored Defense, Martial Arts", "ki_points": ""},
         *           {"level": 2, "proficiency_bonus": "+2", "features": "Ki, Unarmored Movement", "ki_points": "2"}
         *         ]
         *       }
         *     }
         *     ```
         *
         *     ## For Subclasses
         *
         *     When called on a subclass, returns the parent class's progression table
         *     since subclasses inherit the base class progression mechanics.
         */
        get: operations["classes.progression"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/conditions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all D&D conditions
         * @description Returns the 15 D&D 5e conditions, which are status effects applied to creatures during combat.
         *     Conditions modify abilities, movement, actions, and saving throws.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/conditions              # All 15 conditions
         *     GET /api/v1/lookups/conditions?q=blind      # Search by name
         *     ```
         *
         *     **D&D 5e Conditions:**
         *     - **Blinded:** Cannot see, auto-fails sight checks, attacks have disadvantage, attacks against have advantage
         *     - **Charmed:** Cannot attack charmer, charmer has advantage on social checks
         *     - **Deafened:** Cannot hear, auto-fails hearing checks
         *     - **Exhaustion:** Six levels of fatigue, each progressively worse (disadvantage  speed halved  max HP halved  death)
         *     - **Frightened:** Disadvantage on checks/attacks while source visible, cannot move closer to source
         *     - **Grappled:** Speed becomes 0, cannot benefit from bonuses to speed
         *     - **Incapacitated:** Cannot take actions or reactions
         *     - **Invisible:** Impossible to see without special sense, attack rolls have advantage, attacks against have disadvantage
         *     - **Paralyzed:** Incapacitated, auto-fail STR/DEX saves, attacks have advantage, hits within 5ft are critical hits
         *     - **Petrified:** Transformed to stone, incapacitated, unaware of surroundings, resistance to all damage
         *     - **Poisoned:** Disadvantage on attack rolls and ability checks
         *     - **Prone:** Disadvantage on attacks, attacks against have advantage (melee) or disadvantage (ranged), costs half movement to stand
         *     - **Restrained:** Speed 0, disadvantage on DEX saves, attacks have advantage
         *     - **Stunned:** Incapacitated, auto-fail STR/DEX saves, attacks have advantage
         *     - **Unconscious:** Incapacitated, prone, cannot move/speak, unaware, auto-fail STR/DEX saves, attacks have advantage, hits within 5ft are critical hits
         *
         *     **Query Parameters:**
         *     - `q` (string): Search by name (partial match)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - **Combat Tactics:** Identify which conditions to inflict for maximum advantage (Paralyzed = auto-crits)
         *     - **Spell Selection:** Choose control spells based on conditions they inflict (Hold Person = Paralyzed)
         *     - **Monster Abilities:** Understand dangerous monster attacks (Ghoul claws = Paralyzed, Medusa gaze = Petrified)
         *     - **Condition Removal:** Prepare Lesser Restoration (removes Blinded, Deafened, Paralyzed, Poisoned)
         */
        get: operations["lookups.conditions.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/conditions/{condition}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single condition
         * @description Returns detailed information about a specific D&D condition including its description
         *     and mechanical effects. Conditions can be retrieved by ID, slug, or name.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/conditions/1              # By ID
         *     GET /api/v1/lookups/conditions/paralyzed      # By slug
         *     GET /api/v1/lookups/conditions/Paralyzed      # By name
         *     ```
         *
         *     **Response includes:**
         *     - `id`, `name`, `slug`: Condition identification
         *     - `description`: Full mechanical description of the condition's effects
         */
        get: operations["lookups.conditions.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/conditions/{condition}/spells": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all spells that inflict this condition
         * @description Returns a paginated list of spells that can inflict this condition on targets
         *     through saving throw failures. Useful for building control-focused characters
         *     and identifying debuff options.
         *
         *     **Basic Examples:**
         *     - Poison spells: `GET /api/v1/conditions/poisoned/spells`
         *     - Stun spells: `GET /api/v1/conditions/stunned/spells`
         *     - By slug: `GET /api/v1/conditions/grappled/spells`
         *     - Pagination: `GET /api/v1/conditions/paralyzed/spells?per_page=25`
         *
         *     **Common Condition Use Cases:**
         *     - Poisoned: Poison Spray, Cloudkill, Contagion (~8 spells, CON save)
         *     - Stunned: Power Word Stun, Shocking Grasp (high levels) (~4 spells, CON save)
         *     - Paralyzed: Hold Person, Hold Monster (~6 spells, WIS save, auto-crit)
         *     - Charmed: Charm Person, Dominate Monster, Suggestion (~12 spells, WIS save)
         *     - Frightened: Cause Fear, Fear, Phantasmal Killer (~8 spells, WIS save)
         *     - Restrained: Entangle, Web, Evard's Black Tentacles (~10 spells, STR/DEX save)
         *     - Blinded: Blindness/Deafness, Sunburst (~6 spells, CON save)
         *     - Deafened: Deafness, Thunder Step (~4 spells, CON save)
         *     - Prone: Grease, Thunderwave (~8 spells, STR/DEX save)
         *     - Invisible: Invisibility, Greater Invisibility (~6 spells, no save)
         *
         *     **Control Wizard Builds:**
         *     - Crowd control: Paralyzed (auto-crits), Stunned (no actions), Restrained (reduced movement)
         *     - Debuffs: Poisoned (disadvantage on attacks), Frightened (can't approach)
         *     - Social manipulation: Charmed (friendly, can't attack), Suggestion (follow command)
         *
         *     **Combat Tactics:**
         *     - High-value targets: Paralyze enemy spellcasters (no verbal components)
         *     - Melee threats: Restrain or frighten to reduce effectiveness
         *     - Action denial: Stunned removes actions, reactions, and movement
         *     - Save optimization: Target low saves (STR for wizards, INT for beasts)
         *
         *     **Condition Synergies:**
         *     - Paralyzed: Attack rolls auto-crit within 5 feet (massive damage)
         *     - Restrained: Advantage on attacks against target, disadvantage on DEX saves
         *     - Prone: Advantage on melee attacks, disadvantage on ranged attacks
         *     - Invisible: Advantage on attacks, disadvantage on attacks against you
         *
         *     **Reference Data:**
         *     - 15 conditions in D&D 5e
         *     - Most common: Poisoned (~8 spells), Charmed (~12 spells), Frightened (~8 spells)
         *     - Most powerful: Paralyzed (auto-crits), Stunned (no actions), Incapacitated
         *     - Duration: Varies from 1 round to 1 minute (concentration) to permanent
         */
        get: operations["lookups.conditions.spells"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/conditions/{condition}/monsters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all monsters that inflict this condition
         * @description Returns a paginated list of monsters that can inflict this condition through
         *     their attacks, traits, special abilities, or innate spellcasting. Useful for
         *     DMs designing encounters and players understanding enemy threats.
         *
         *     **Basic Examples:**
         *     - Poisoning monsters: `GET /api/v1/conditions/poisoned/monsters`
         *     - Paralyzing monsters: `GET /api/v1/conditions/paralyzed/monsters`
         *     - By slug: `GET /api/v1/conditions/frightened/monsters`
         *     - Pagination: `GET /api/v1/conditions/frightened/monsters?per_page=25`
         *
         *     **Common Condition Monsters:**
         *     - Poisoned: Yuan-ti, Giant Spiders, Carrion Crawlers (~40 monsters)
         *     - Paralyzed: Ghouls, Gelatinous Cubes, Beholders (paralysis ray) (~25 monsters)
         *     - Frightened: Dragons (frightful presence), Banshees, Death Knights (~30 monsters)
         *     - Charmed: Succubus/Incubus, Vampires, Sirens (~15 monsters)
         *     - Stunned: Mind Flayers (mind blast), Monks (stunning strike) (~10 monsters)
         *     - Restrained: Giant Spiders (webs), Ropers, Vine Blights (~20 monsters)
         *     - Blinded: Umber Hulks (confusing gaze), Basilisks (~8 monsters)
         *     - Petrified: Basilisks, Medusas, Cockatrices (~6 monsters)
         *     - Grappled: Giant Octopuses, Mimics, Ropers (~35 monsters)
         *
         *     **DM Encounter Design:**
         *     - Threat assessment: Identify monsters with debilitating conditions
         *     - Tactical variety: Mix damage dealers with control monsters
         *     - Save targeting: Combine STR/DEX conditions with INT/WIS/CHA conditions
         *     - Difficulty scaling: Paralysis/Stun can swing encounters dramatically
         *
         *     **Player Preparation:**
         *     - Condition immunity: Paladins (Aura of Protection), Monks (Diamond Soul)
         *     - Lesser Restoration: Cures poisoned, paralyzed, blinded, deafened
         *     - Greater Restoration: Cures charmed, petrified, stunned, exhaustion
         *     - Protection spells: Protection from Poison, Heroes' Feast (poison immunity)
         *
         *     **Dangerous Monster Conditions:**
         *     - Paralyzed: Auto-crits from melee attacks (ghouls, gelatinous cubes)
         *     - Petrified: Permanent until Greater Restoration (medusas, basilisks)
         *     - Stunned: No actions, failed STR/DEX saves (mind flayers)
         *     - Frightened: Cannot move closer (ancient dragons, death knights)
         *
         *     **Condition Delivery Mechanisms:**
         *     - Saving throws: Most common (CON for poison, WIS for charm/fear)
         *     - Attack hits: Ghoul claws (paralysis), spider bites (poison)
         *     - Failed ability checks: Gelatinous cube engulf (paralysis)
         *     - Aura effects: Dragon frightful presence (WIS save), banshee wail
         *
         *     **Reference Data:**
         *     - 15 conditions total
         *     - Most common monster conditions: Poisoned (~40), Frightened (~30), Grappled (~35)
         *     - Most dangerous: Paralyzed (auto-crits), Petrified (permanent), Stunned (helpless)
         *     - CR correlation: Higher CR monsters inflict more conditions simultaneously
         */
        get: operations["lookups.conditions.monsters"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/damage-types/{damageType}/spells": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all spells that deal this damage type
         * @description Returns a paginated list of spells that deal this type of damage through their
         *     primary or secondary effects. Useful for building themed characters (fire mage,
         *     frost wizard) or finding spells to exploit enemy vulnerabilities.
         *
         *     **Basic Examples:**
         *     - Fire spells: `GET /api/v1/damage-types/fire/spells`
         *     - Fire by code: `GET /api/v1/damage-types/F/spells`
         *     - Pagination: `GET /api/v1/damage-types/fire/spells?per_page=25&page=2`
         *
         *     **Damage Type Use Cases:**
         *     - Fire: Fireball, Burning Hands, Scorching Ray, Flame Strike (~24 spells)
         *     - Cold: Ice Storm, Cone of Cold, Ray of Frost (~18 spells)
         *     - Lightning: Lightning Bolt, Call Lightning, Chain Lightning (~12 spells)
         *     - Psychic: Mind Spike, Synaptic Static, Psychic Scream (~15 spells)
         *     - Necrotic: Blight, Vampiric Touch, Circle of Death (~20 spells)
         *     - Radiant: Guiding Bolt, Sunbeam, Dawn, Sacred Flame (~16 spells)
         *     - Thunder: Thunderwave, Shatter, Booming Blade (~10 spells)
         *     - Poison: Poison Spray, Cloudkill, Stinking Cloud (~8 spells)
         *     - Acid: Acid Splash, Vitriolic Sphere, Acid Arrow (~7 spells)
         *     - Force: Magic Missile, Eldritch Blast, Disintegrate (~12 spells)
         *
         *     **Character Building:**
         *     - Elemental specialist builds (fire/cold/lightning mages)
         *     - Exploit enemy vulnerabilities (undead vulnerable to radiant)
         *     - Avoid resistances (many devils resist fire, use cold/lightning instead)
         *     - Thematic spell selection (necromancer uses necrotic, cleric uses radiant)
         *
         *     **Combat Tactics:**
         *     - Identify damage type distribution in your spell list
         *     - Prepare diverse damage types to handle resistances
         *     - Focus on force/psychic for guaranteed damage (few resistances)
         *
         *     **Reference Data:**
         *     - 13 damage types in D&D 5e
         *     - Most common: Fire (~24 spells), Necrotic (~20 spells), Cold (~18 spells)
         *     - Least resisted: Force, Psychic, Radiant (best for reliable damage)
         *     - Most resisted: Fire, Poison (many creatures have resistance/immunity)
         */
        get: operations["lookups.damage-types.spells"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/damage-types/{damageType}/items": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all items that deal this damage type
         * @description Returns a paginated list of weapons, ammunition, and magic items that deal
         *     this type of damage. Useful for optimizing weapon selection and finding items
         *     that exploit enemy vulnerabilities.
         *
         *     **Basic Examples:**
         *     - Slashing weapons: `GET /api/v1/damage-types/slashing/items`
         *     - Fire items: `GET /api/v1/damage-types/fire/items`
         *     - Slashing by code: `GET /api/v1/damage-types/S/items`
         *     - Pagination: `GET /api/v1/damage-types/slashing/items?per_page=50`
         *
         *     **Physical Damage Types (Weapons):**
         *     - Slashing: Longsword, Greatsword, Scimitar, Battleaxe (~80 items)
         *     - Piercing: Rapier, Longbow, Shortbow, Dagger, Pike (~70 items)
         *     - Bludgeoning: Mace, Warhammer, Club, Quarterstaff, Maul (~60 items)
         *
         *     **Elemental Damage Types (Magic Items):**
         *     - Fire: Flame Tongue, Fire Arrow, Javelin of Lightning (~12 items)
         *     - Cold: Frost Brand, Arrows of Ice Slaying (~5 items)
         *     - Lightning: Javelin of Lightning, Lightning Arrow (~4 items)
         *     - Poison: Serpent Venom (poison), Poison Dagger (~6 items)
         *     - Acid: Acid Vial, Acid Arrow (~3 items)
         *
         *     **Character Building:**
         *     - Martial characters: Identify all weapons matching your proficiencies
         *     - Damage optimization: Find magic weapons with bonus elemental damage
         *     - Versatility: Carry multiple damage types to bypass resistances
         *     - Exploit vulnerabilities: Trolls regenerate except for fire/acid damage
         *
         *     **Combat Tactics:**
         *     - Physical damage: Most common, many creatures resist
         *     - Magical slashing/piercing/bludgeoning: Bypass non-magical resistance
         *     - Elemental damage: Exploit specific vulnerabilities (fire vs. ice creatures)
         *
         *     **Reference Data:**
         *     - 13 damage types total
         *     - Physical types: Slashing (~80), Piercing (~70), Bludgeoning (~60)
         *     - Elemental types: Fire (~12), Poison (~6), Cold (~5), Lightning (~4)
         *     - Magic weapons override resistances to non-magical damage
         */
        get: operations["lookups.damage-types.items"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/damage-types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all damage types
         * @description Returns the 13 D&D 5e damage types used for spell effects, weapon damage, and creature resistances/immunities.
         *     Damage types are divided into physical (Slashing, Piercing, Bludgeoning) and elemental/energy types.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/damage-types              # All 13 damage types
         *     GET /api/v1/lookups/damage-types?q=fire       # Search by name
         *     ```
         *
         *     **Damage Types Reference:**
         *     - **Physical (3):** Slashing, Piercing, Bludgeoning - from weapons, most common
         *     - **Elemental (4):** Fire, Cold, Lightning, Acid - natural elements
         *     - **Energy (3):** Force, Radiant, Necrotic - magical energy
         *     - **Other (3):** Poison, Psychic, Thunder - special types
         *
         *     **Query Parameters:**
         *     - `q` (string): Search by name (partial match)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - **Resistance Planning:** Check enemy resistances before combat (many undead resist necrotic)
         *     - **Spell Selection:** Build diverse spell lists with multiple damage types
         *     - **Vulnerability Exploitation:** Target known vulnerabilities (trolls vs. fire/acid)
         */
        get: operations["lookups.damage-types.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/damage-types/{damageType}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single damage type
         * @description Returns detailed information about a specific D&D damage type including its name and code.
         *     Damage types can be retrieved by ID, slug, code, or name.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/damage-types/1              # By ID
         *     GET /api/v1/lookups/damage-types/fire           # By slug
         *     GET /api/v1/lookups/damage-types/F              # By code
         *     GET /api/v1/lookups/damage-types/Fire           # By name
         *     ```
         *
         *     **Response includes:**
         *     - `id`, `name`, `slug`: Damage type identification
         *     - `code`: Single-letter abbreviation (F=Fire, C=Cold, L=Lightning, etc.)
         */
        get: operations["lookups.damage-types.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/feats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all feats
         * @description Returns a paginated list of 138 D&D 5e feats. Use `?filter=` for filtering and `?q=` for full-text search.
         *
         *     **Common Examples:**
         *     ```
         *     GET /api/v1/feats                                              # All feats
         *     GET /api/v1/feats?filter=has_prerequisites = false             # Feats without prerequisites (18 feats)
         *     GET /api/v1/feats?filter=improved_abilities IN [STR]           # STR-boosting feats (Heavy Armor Master, Athlete)
         *     GET /api/v1/feats?filter=prerequisite_types IN [Race]          # Race-specific feats (Elven Accuracy, Dwarven Fortitude)
         *     GET /api/v1/feats?filter=grants_proficiencies = true           # Feats that grant proficiencies (Weapon Master, Skill Expert)
         *     GET /api/v1/feats?filter=tag_slugs IN [combat]                 # Combat feats
         *     GET /api/v1/feats?q=advantage                                  # Full-text search for "advantage"
         *     GET /api/v1/feats?q=spell&filter=improved_abilities IN [INT, WIS, CHA]  # Magic feats with ASI
         *     ```
         *
         *     **Filterable Fields by Data Type:**
         *
         *     **Integer Fields** (Operators: `=`, `!=`, `>`, `>=`, `<`, `<=`, `TO`):
         *     - `id` (int): Feat ID
         *       - Examples: `id = 42`, `id >= 10`, `id 1 TO 50`
         *       - Use case: Direct reference or batch processing ranges
         *
         *     **String Fields** (Operators: `=`, `!=`):
         *     - `slug` (string): URL-friendly feat identifier
         *       - Examples: `slug = heavy-armor-master`, `slug != alert`
         *       - Use case: Direct lookup by slug for permalinks
         *
         *     **Boolean Fields** (Operators: `=`, `!=`, `IS NULL`, `EXISTS`):
         *     - `has_prerequisites` (bool): Feat has prerequisites (race, ability, or proficiency)
         *       - Examples: `has_prerequisites = false`, `has_prerequisites = true`
         *       - Use case: Find feats accessible at level 1 without requirements
         *     - `grants_proficiencies` (bool): Feat grants weapon, armor, tool, or skill proficiencies
         *       - Examples: `grants_proficiencies = true`, `grants_proficiencies = false`
         *       - Use case: Find proficiency-granting feats for skill/equipment access
         *     - `is_half_feat` (bool): Feat grants +1 to an ability score (half-feats)
         *       - Examples: `is_half_feat = true`, `is_half_feat = false`
         *       - Use case: Find feats for odd ability scores (15 STR  16 STR + feat benefits)
         *
         *     **Array Fields** (Operators: `IN`, `NOT IN`, `IS EMPTY`):
         *     - `improved_abilities` (array): Ability codes improved by this feat (STR, DEX, CON, INT, WIS, CHA)
         *       - Examples: `improved_abilities IN [STR]`, `improved_abilities IN [INT, WIS, CHA]`, `improved_abilities IS EMPTY`
         *       - Use case: ASI decisions - find feats that boost specific abilities (Half-Feats)
         *       - Critical for: Heavy Armor Master (+1 STR), Resilient (+1 any), Fey Touched (+1 INT/WIS/CHA)
         *     - `prerequisite_types` (array): Type of prerequisites required (Race, AbilityScore, ProficiencyType)
         *       - Examples: `prerequisite_types IN [Race]`, `prerequisite_types IN [AbilityScore]`, `prerequisite_types IS EMPTY`
         *       - Use case: Find race-locked feats (Elven Accuracy) or ability-gated feats (Heavy Armor Master requires STR 13)
         *     - `tag_slugs` (array): Tag slugs categorizing feat purpose (combat, magic, skill-improvement, etc.)
         *       - Examples: `tag_slugs IN [combat]`, `tag_slugs IN [magic]`, `tag_slugs IS EMPTY`
         *       - Use case: Browse feats by theme or build archetype
         *     - `source_codes` (array): Source book codes (PHB, XGE, TCoE, etc.)
         *       - Examples: `source_codes IN [PHB]`, `source_codes IN [XGE, TCoE]`, `source_codes NOT IN [UA]`
         *       - Use case: Filter by allowed sourcebooks for campaign restrictions
         *
         *     **String Fields** (Operators: `=`, `!=`):
         *     - `parent_feat_slug` (string|null): Parent slug for variant feats (Resilient, Elemental Adept, etc.)
         *       - Examples: `parent_feat_slug = resilient`, `parent_feat_slug = elemental-adept`
         *       - Use case: Group all variants of a feat together (e.g., all Resilient variants)
         *       - Note: Returns null for non-variant feats (Great Weapon Master, Lucky, etc.)
         *
         *     **Complex Filter Examples:**
         *     - STR combat feats: `?filter=improved_abilities IN [STR] AND tag_slugs IN [combat]`
         *     - Feats without prerequisites: `?filter=has_prerequisites = false`
         *     - Race-specific feats with ASI: `?filter=prerequisite_types IN [Race] AND improved_abilities IS NOT EMPTY`
         *     - Magic feats with ability boosts: `?filter=tag_slugs IN [magic] AND improved_abilities IN [INT, WIS, CHA]`
         *     - Proficiency-granting feats: `?filter=grants_proficiencies = true AND has_prerequisites = false`
         *     - PHB-only feats without prerequisites: `?filter=source_codes IN [PHB] AND has_prerequisites = false`
         *     - Combat feats with DEX or STR boost: `?filter=tag_slugs IN [combat] AND improved_abilities IN [STR, DEX]`
         *     - Level 1 accessible ASI feats: `?filter=has_prerequisites = false AND improved_abilities IS NOT EMPTY`
         *     - All half-feats: `?filter=is_half_feat = true`
         *     - Half-feats with STR boost: `?filter=is_half_feat = true AND improved_abilities IN [STR]`
         *     - All Resilient variants: `?filter=parent_feat_slug = resilient`
         *     - All Elemental Adept variants: `?filter=parent_feat_slug = elemental-adept`
         *
         *     **Use Cases:**
         *     - **Character Building:** "Which feats boost STR and help in combat?" (`improved_abilities IN [STR] AND tag_slugs IN [combat]`)
         *     - **ASI Decisions:** "Should I take +2 ASI or a half-feat?" (`improved_abilities IS NOT EMPTY`)
         *     - **Race Synergy:** "What feats are exclusive to Elves?" (`prerequisite_types IN [Race]` + full-text search)
         *     - **Level 1 Variant Human:** "Which feats can I take at level 1?" (`has_prerequisites = false`)
         *     - **Build Planning:** "Find magic feats with INT boost" (`tag_slugs IN [magic] AND improved_abilities IN [INT]`)
         *     - **Equipment Access:** "Which feats grant armor proficiencies?" (`grants_proficiencies = true` + search "armor")
         *
         *     **Operator Reference:**
         *     See `docs/MEILISEARCH-FILTER-OPERATORS.md` for comprehensive operator documentation.
         *
         *     **Query Parameters:**
         *     - `q` (string): Full-text search (searches name, description, prerequisites_text)
         *     - `filter` (string): Meilisearch filter expression
         *     - `sort_by` (string): name, created_at, updated_at (default: name)
         *     - `sort_direction` (string): asc, desc (default: asc)
         *     - `per_page` (int): 1-100 (default: 15)
         *     - `page` (int): Page number (default: 1)
         */
        get: operations["feats.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/feats/{feat}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single feat
         * @description Returns detailed information about a specific feat including modifiers, proficiencies,
         *     conditions, prerequisites, and source citations. Supports selective relationship loading.
         */
        get: operations["feats.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/items": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all items
         * @description Returns a paginated list of 2,232 D&D 5e items including weapons, armor, and magic items. Use `?filter=` for filtering and `?q=` for full-text search.
         *
         *     **Common Examples:**
         *     ```
         *     GET /api/v1/items                                          # All items
         *     GET /api/v1/items?filter=is_magic = true                   # Magic items only
         *     GET /api/v1/items?filter=type_code = HA                    # Heavy armor
         *     GET /api/v1/items?filter=rarity = legendary                # Legendary items
         *     GET /api/v1/items?filter=requires_attunement = true        # Attunement items
         *     GET /api/v1/items?filter=spell_slugs IN [fireball]         # Items with Fireball
         *     GET /api/v1/items?q=staff                                  # Full-text search for "staff"
         *     GET /api/v1/items?q=sword&filter=is_magic = true           # Search + filter combined
         *     ```
         *
         *     **Filterable Fields by Data Type:**
         *
         *     **Integer Fields** (Operators: `=`, `!=`, `>`, `>=`, `<`, `<=`, `TO`):
         *     - `id` (int): Item ID
         *     - `weight` (float): Weight in pounds
         *       - Examples: `weight <= 1.0`, `weight >= 5`, `weight 1 TO 10`
         *     - `cost_cp` (int): Cost in copper pieces (100cp = 1gp)
         *       - Examples: `cost_cp >= 5000` (50+ gold), `cost_cp 100 TO 1000` (1-10gp)
         *     - `range_normal` (int): Normal range in feet (ranged weapons)
         *       - Examples: `range_normal >= 80`, `range_normal > 0` (has range)
         *     - `range_long` (int): Long range in feet (ranged weapons)
         *     - `armor_class` (int): Base armor class (armor only)
         *       - Examples: `armor_class >= 16`, `armor_class 14 TO 18`
         *     - `strength_requirement` (int): Minimum strength to wear (heavy armor)
         *       - Examples: `strength_requirement > 0` (has requirement)
         *     - `charges_max` (int): Maximum charges (magic items)
         *       - Examples: `charges_max >= 10`, `charges_max 5 TO 20`
         *
         *     **String Fields** (Operators: `=`, `!=`):
         *     - `slug` (string): URL-friendly identifier
         *     - `type_name` (string): Full type name (Heavy Armor, Wand, Staff, etc.)
         *     - `type_code` (string): Two-letter type code (HA, WD, ST, RD, SCR, P, etc.)
         *       - Examples: `type_code = HA` (heavy armor), `type_code = WD` (wands)
         *     - `rarity` (string): common, uncommon, rare, very_rare, legendary, artifact
         *       - Examples: `rarity = legendary`, `rarity != common`
         *     - `damage_dice` (string): Damage dice (1d8, 2d6, etc.)
         *     - `versatile_damage` (string): Versatile damage dice
         *     - `damage_type` (string): Damage type (Slashing, Piercing, Bludgeoning, Fire, etc.)
         *     - `recharge_timing` (string): When charges recharge (dawn, dusk, etc.)
         *     - `recharge_formula` (string): Recharge dice formula (1d6+4, etc.)
         *
         *     **Boolean Fields** (Operators: `=`, `!=`, `IS NULL`, `EXISTS`):
         *     - `requires_attunement` (bool): Requires attunement
         *       - Examples: `requires_attunement = true`, `requires_attunement = false`
         *     - `is_magic` (bool): Magic item
         *       - Examples: `is_magic = true`
         *     - `stealth_disadvantage` (bool): Imposes disadvantage on Stealth (heavy armor)
         *       - Examples: `stealth_disadvantage = false` (silent armor)
         *     - `has_charges` (bool): Item has charges
         *       - Examples: `has_charges = true`
         *     - `has_prerequisites` (bool): Has class/race/level prerequisites
         *       - Examples: `has_prerequisites = true`
         *
         *     **Computed Fields** (Operators vary by type):
         *     - `proficiency_category` (string): Weapon proficiency type
         *       - Values: simple_melee, martial_melee, simple_ranged, martial_ranged, or null for non-weapons
         *       - Examples: `proficiency_category = martial_melee`, `proficiency_category = simple_ranged`
         *     - `magic_bonus` (int): Magic bonus (+1/+2/+3) from modifiers, null for non-magic items
         *       - Examples: `magic_bonus = 2`, `magic_bonus >= 1`, `magic_bonus EXISTS`
         *
         *     **Array Fields** (Operators: `IN`, `NOT IN`, `IS EMPTY`):
         *     - `source_codes` (array): Source book codes (PHB, DMG, XGE, TCoE, etc.)
         *       - Examples: `source_codes IN [PHB, DMG]`, `source_codes NOT IN [UA]`
         *     - `spell_slugs` (array): Spell slugs associated with item
         *       - Examples: `spell_slugs IN [fireball]`, `spell_slugs IS EMPTY`
         *     - `tag_slugs` (array): Tag slugs
         *       - Examples: `tag_slugs IN [fire]`, `tag_slugs IS EMPTY`
         *     - `property_codes` (array): Weapon/armor property codes (F=Finesse, V=Versatile, etc.)
         *       - Examples: `property_codes IN [F]` (finesse weapons)
         *     - `modifier_categories` (array): Stat modifier categories
         *       - Examples: `modifier_categories IN [ability_score]`
         *     - `proficiency_names` (array): Required proficiency names
         *       - Examples: `proficiency_names IN [martial weapons]`
         *     - `saving_throw_abilities` (array): Saving throw ability codes (STR, DEX, CON, INT, WIS, CHA)
         *       - Examples: `saving_throw_abilities IN [DEX]`, `saving_throw_abilities IS EMPTY`
         *
         *     **Complex Filter Examples:**
         *     - Heavy armor with high AC: `?filter=type_code = HA AND armor_class >= 16`
         *     - Ranged weapons: `?filter=range_normal >= 80`
         *     - Magic items with charges: `?filter=is_magic = true AND has_charges = true`
         *     - Finesse weapons: `?filter=property_codes IN [F] AND type_code = M`
         *     - Silent heavy armor: `?filter=type_code = HA AND stealth_disadvantage = false`
         *     - Affordable magic items: `?filter=is_magic = true AND cost_cp <= 10000` (100gp or less)
         *     - Legendary items requiring attunement: `?filter=rarity = legendary AND requires_attunement = true`
         *     - Items with prerequisites: `?filter=has_prerequisites = true`
         *     - All martial melee weapons: `?filter=proficiency_category = martial_melee`
         *     - Simple ranged weapons: `?filter=proficiency_category = simple_ranged`
         *     - +2 or better magic weapons: `?filter=magic_bonus >= 2`
         *     - +1 martial longswords: `?filter=proficiency_category = martial_melee AND magic_bonus = 1`
         *
         *     **Use Cases:**
         *     - Shopping lists: Filter by cost range and item type
         *     - Loot tables: Filter by rarity and magic status
         *     - Equipment planning: Filter by weight for encumbrance
         *     - Class builds: Filter by weapon properties and proficiencies
         *     - Magic item search: Filter by spell effects and attunement
         *     - Armor optimization: Filter by AC, stealth, and strength requirement
         *
         *     **Operator Reference:**
         *     See `docs/MEILISEARCH-FILTER-OPERATORS.md` for comprehensive operator documentation.
         *
         *     **Query Parameters:**
         *     - `q` (string): Full-text search (searches name, description)
         *     - `filter` (string): Meilisearch filter expression
         *     - `sort_by` (string): name, weight, cost_cp, armor_class, created_at, updated_at (default: name)
         *     - `sort_direction` (string): asc, desc (default: asc)
         *     - `per_page` (int): 1-100 (default: 15)
         *     - `page` (int): Page number (default: 1)
         */
        get: operations["items.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/items/{item}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single item
         * @description Returns detailed information about a specific item including item type, damage type,
         *     properties, abilities, random tables, modifiers, proficiencies, and prerequisites.
         *     Supports selective relationship loading via the 'include' parameter.
         */
        get: operations["items.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/item-properties": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all item properties
         * @description Returns D&D 5e item properties - special characteristics that modify how weapons
         *     and equipment function in combat and gameplay.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/item-properties              # All properties
         *     GET /api/v1/lookups/item-properties?q=finesse    # Search by name
         *     GET /api/v1/lookups/item-properties?q=two        # Find two-handed, etc.
         *     ```
         *
         *     **Common Weapon Properties:**
         *     - **Finesse (F):** Use DEX or STR for attack/damage (Rapier, Dagger, Shortsword)
         *     - **Versatile (V):** One or two-handed with different damage dice (Longsword, Battleaxe)
         *     - **Two-Handed (2H):** Requires both hands (Greatsword, Greataxe, Longbow)
         *     - **Light (L):** Can be used for two-weapon fighting (Dagger, Shortsword, Handaxe)
         *     - **Heavy (H):** Small creatures have disadvantage (Greataxe, Heavy Crossbow)
         *     - **Reach (R):** 10 ft. reach instead of 5 ft. (Glaive, Halberd, Pike)
         *     - **Thrown (T):** Can be thrown for ranged attacks (Javelin, Handaxe, Dagger)
         *     - **Loading (LD):** One attack per action regardless of Extra Attack (Crossbows)
         *     - **Ammunition (A):** Requires ammunition (Bows, Crossbows)
         *     - **Special (S):** Unique rules (Lance, Net)
         *
         *     **Query Parameters:**
         *     - `q` (string): Search properties by name (partial match)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - **Weapon Selection:** Find finesse weapons for DEX-based fighters
         *     - **Two-Weapon Fighting:** Browse light weapons for dual wielding
         *     - **Build Optimization:** Find versatile weapons for flexibility
         *     - **Feat Planning:** Identify heavy weapons for Great Weapon Master
         */
        get: operations["lookups.item-properties.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/item-properties/{itemProperty}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single item property
         * @description Returns detailed information about a specific item property.
         *     Properties can be retrieved by ID, code, slug, or name.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/item-properties/3           # By ID
         *     GET /api/v1/lookups/item-properties/F           # By code
         *     GET /api/v1/lookups/item-properties/finesse     # By slug
         *     GET /api/v1/lookups/item-properties/Finesse     # By name
         *     ```
         *
         *     **Response includes:**
         *     - `id`, `code`, `name`, `slug`: Property identification
         *     - `description`: Rules text explaining how this property works
         *
         *     **Related:** Use `/api/v1/items?filter=property_codes IN [F]` to list all items with this property.
         */
        get: operations["lookups.item-properties.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/item-types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all item types
         * @description Returns D&D 5e item type categories used to classify equipment and magical items.
         *     Each item in the database belongs to exactly one item type.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/item-types              # All item types
         *     GET /api/v1/lookups/item-types?q=weapon     # Search by name
         *     GET /api/v1/lookups/item-types?q=wondrous   # Find wondrous items category
         *     ```
         *
         *     **Common Item Types:**
         *     - **Weapon (W):** Swords, axes, bows, crossbows, etc.
         *     - **Armor (LA/MA/HA):** Light, Medium, Heavy armor and shields
         *     - **Potion (P):** Consumable magical liquids
         *     - **Scroll (SC):** Single-use spell scrolls
         *     - **Wand (WD):** Spellcasting focus items
         *     - **Rod (RD):** Magical rod items
         *     - **Staff (ST):** Magical staves
         *     - **Ring (RG):** Magical rings
         *     - **Wondrous Item (G):** Miscellaneous magic items (cloaks, boots, etc.)
         *     - **Adventuring Gear (G):** Non-magical equipment
         *
         *     **Query Parameters:**
         *     - `q` (string): Search item types by name (partial match)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - **Item Browsing:** Filter the /items endpoint by type_code to browse categories
         *     - **Treasure Generation:** Pick random items from specific categories
         *     - **Character Equipment:** Find all weapons or armor available
         *     - **Magic Item Shopping:** Browse wondrous items, rings, or wands
         */
        get: operations["lookups.item-types.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/item-types/{itemType}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single item type
         * @description Returns detailed information about a specific item type category.
         *     Item types can be retrieved by ID, code, slug, or name.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/item-types/5           # By ID
         *     GET /api/v1/lookups/item-types/W           # By code
         *     GET /api/v1/lookups/item-types/weapon      # By slug
         *     GET /api/v1/lookups/item-types/Weapon      # By name
         *     ```
         *
         *     **Response includes:**
         *     - `id`, `code`, `name`, `slug`: Item type identification
         *     - `description`: What this item type represents
         *
         *     **Related:** Use `/api/v1/items?filter=type_code = W` to list all items of this type.
         */
        get: operations["lookups.item-types.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/languages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all D&D languages
         * @description Returns all languages available in D&D 5e. Languages represent spoken and written
         *     communication systems used by races, creatures, and cultures across the multiverse.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/languages              # All languages
         *     GET /api/v1/lookups/languages?q=elvish     # Search by name
         *     ```
         *
         *     **Standard Languages:**
         *     - **Common:** Universal language spoken by most humanoids
         *     - **Dwarvish:** Language of dwarves, uses Dwarvish script
         *     - **Elvish:** Language of elves, uses Elvish script
         *     - **Giant:** Language of giants and ogres
         *     - **Gnomish:** Language of gnomes, uses Dwarvish script
         *     - **Goblin:** Language of goblinoids, uses Dwarvish script
         *     - **Halfling:** Language of halflings, uses Common script
         *     - **Orc:** Language of orcs, uses Dwarvish script
         *
         *     **Exotic Languages:**
         *     - **Abyssal:** Language of demons (Chaotic Evil planes)
         *     - **Celestial:** Language of angels (Good-aligned planes)
         *     - **Draconic:** Language of dragons, dragonborn, and kobolds
         *     - **Deep Speech:** Language of aberrations (mind flayers, beholders)
         *     - **Infernal:** Language of devils (Lawful Evil planes)
         *     - **Primordial:** Elemental language with dialects (Aquan, Auran, Ignan, Terran)
         *     - **Sylvan:** Language of fey creatures
         *     - **Undercommon:** Trade language of the Underdark
         *
         *     **Query Parameters:**
         *     - `q` (string): Search by name (partial match)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - **Character Creation:** Choose languages based on race and background
         *     - **Campaign Planning:** Identify languages needed for specific settings (Underdark, Planes, etc.)
         *     - **Roleplay:** Determine if characters can communicate with NPCs or creatures
         */
        get: operations["lookups.languages.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/languages/{language}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single language
         * @description Returns detailed information about a specific D&D language including its script,
         *     typical speakers, and description. Languages can be retrieved by ID, slug, or name.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/languages/1              # By ID
         *     GET /api/v1/lookups/languages/elvish         # By slug
         *     GET /api/v1/lookups/languages/Elvish         # By name
         *     ```
         *
         *     **Response includes:**
         *     - `id`, `name`, `slug`: Language identification
         *     - `script`: Writing system (Common, Dwarvish, Elvish, Draconic, Infernal, Celestial)
         *     - `typical_speakers`: Races or creatures that commonly speak this language
         *     - `description`: Lore and usage information
         */
        get: operations["lookups.languages.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/languages/{language}/races": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all races that speak this language natively or as a choice
         * @description Returns races that either automatically know this language or can choose it as a racial
         *     language option. Use this to find which races provide access to specific languages for
         *     character building or to understand language distribution across the world.
         *
         *     **Examples:**
         *     ```bash
         *     # By slug (most common)
         *     GET /api/v1/languages/elvish/races
         *     GET /api/v1/languages/draconic/races
         *     GET /api/v1/languages/common/races
         *
         *     # By numeric ID
         *     GET /api/v1/languages/gnomish/races?per_page=25
         *     ```
         *
         *     **Common Language  Race Queries:**
         *     - **Common:** Human, Half-Elf, Half-Orc, most other races (universal language)
         *     - **Elvish:** Elf, Half-Elf, Eladrin
         *     - **Dwarvish:** Dwarf, Duergar
         *     - **Draconic:** Dragonborn, Kobold, Half-Dragon
         *     - **Undercommon:** Drow, Deep Gnome, Svirfneblin (Underdark languages)
         *     - **Infernal:** Tiefling (heritage language)
         *     - **Primordial:** Genasi (elemental languages)
         *     - **Sylvan:** Wood Elf, Forest Gnome (fey languages)
         *
         *     **Use Cases:**
         *     - **Race selection:** "I want to speak Elvish - which races work?"  Query `/languages/elvish/races`
         *     - **Campaign planning:** "Which races speak Infernal for my Avernus campaign?"  Check Tiefling variants
         *     - **Lore building:** "Which races communicate with dragons?"  Query Draconic speakers
         *     - **Party composition:** "We need someone who speaks Undercommon for Underdark exploration"
         *     - **Multilingual characters:** Combine race language with background language for 3+ languages
         *
         *     **Language Distribution (Approximate):**
         *     - **Standard Languages** (all races): Common (30 races), Elvish (8 races), Dwarvish (4 races), Draconic (5 races)
         *     - **Exotic Languages** (rare): Abyssal (1 race), Infernal (2 races), Celestial (1 race), Deep Speech (0 races)
         *     - **Regional Languages:** Primordial (4 dialects), Sylvan (3 races), Undercommon (5 Underdark races)
         *
         *     **Character Building Tips:**
         *     - Most campaigns need Common + 1-2 specialized languages (dungeon exploration, diplomacy)
         *     - Choose languages based on campaign setting (Underdark  Undercommon, Planar  Infernal/Celestial)
         *     - Thieves' Cant is only available via Criminal/Urchin backgrounds (not racial)
         *     - Druids automatically learn Druidic (not queryable via this endpoint - class feature)
         *
         *     **Response Format:**
         *     Returns paginated race data with size, speed, sources, and traits. Default 50 results per page.
         *     Use `per_page` parameter to adjust pagination (max 100).
         */
        get: operations["lookups.languages.races"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/languages/{language}/backgrounds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all backgrounds that teach or grant this language
         * @description Returns backgrounds that provide access to this language, either as a fixed language grant
         *     or as a language choice. Use this to plan character backgrounds that grant specific languages
         *     or to understand which backgrounds provide linguistic diversity.
         *
         *     **Examples:**
         *     ```bash
         *     # By slug (most common)
         *     GET /api/v1/languages/thieves-cant/backgrounds
         *     GET /api/v1/languages/elvish/backgrounds
         *     GET /api/v1/languages/common/backgrounds
         *
         *     # By numeric ID
         *     GET /api/v1/languages/orc/backgrounds?per_page=20
         *     ```
         *
         *     **Common Language  Background Queries:**
         *     - **Thieves' Cant:** Criminal, Urchin (only these backgrounds teach this secret language!)
         *     - **Common:** Most backgrounds grant Common or assume it (universal language)
         *     - **Dwarvish:** Guild Artisan (if Dwarf-focused), Folk Hero (mountainous regions)
         *     - **Elvish:** Sage (elven libraries), Outlander (elven forests)
         *     - **Exotic Languages:** Acolyte (Celestial, Infernal), Sage (any language), Hermit (choice)
         *
         *     **Use Cases:**
         *     - **Background selection:** "I want Thieves' Cant - which backgrounds work?"  Only Criminal/Urchin
         *     - **Language optimization:** "I need 3+ languages - which backgrounds help?"  Sage (2 choices), Acolyte (2 languages)
         *     - **Campaign alignment:** "Urban campaign needs urban languages"  Criminal, Charlatan, Urchin
         *     - **Rare language access:** "How do I get Deep Speech without being Far Realm-touched?"  Sage background
         *     - **Multilingual builds:** Combine race languages + background languages + class features
         *
         *     **Background Language Patterns:**
         *     - **Standard Backgrounds:** Grant 1-2 common languages (Common, regional language)
         *     - **Criminal/Urchin:** Only backgrounds that grant Thieves' Cant
         *     - **Sage:** Most flexible - can choose 2 languages from any list
         *     - **Acolyte:** Grants 2 languages (often Celestial or Infernal based on deity)
         *     - **Outlander:** Grants 1 language (often regional or tribal)
         *
         *     **Language Acquisition Priority:**
         *     1. **Race languages** (automatic, usually 2-3 languages including Common)
         *     2. **Background languages** (1-2 additional languages, often campaign-specific)
         *     3. **Class features** (Druid  Druidic, Ranger  one favored enemy language)
         *     4. **Feats** (Linguist feat  3 additional languages + ciphers)
         *
         *     **Character Building Tips:**
         *     - Most characters start with 2-4 languages (race + background)
         *     - Choose background languages based on campaign (dungeon  Undercommon, planar  Infernal/Celestial)
         *     - Thieves' Cant is secret and not counted against language limits
         *     - Consider taking Sage background if you need rare languages (Deep Speech, Primordial)
         *     - Language proficiency can enable social encounters, lore discovery, and avoid combat
         *
         *     **Response Format:**
         *     Returns paginated background data with traits, proficiencies, and sources. Default 50 results per page.
         *     Use `per_page` parameter to adjust pagination (max 100).
         */
        get: operations["lookups.languages.backgrounds"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/monsters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all monsters
         * @description Returns a paginated list of 598 D&D 5e monsters. Use `?filter=` for filtering and `?q=` for full-text search.
         *
         *     **Common Examples:**
         *     ```
         *     GET /api/v1/monsters                                       # All monsters
         *     GET /api/v1/monsters?filter=challenge_rating >= 20         # Boss fights (CR 20+)
         *     GET /api/v1/monsters?filter=type = dragon                  # Dragons only
         *     GET /api/v1/monsters?filter=is_spellcaster = true          # Spellcasting monsters
         *     GET /api/v1/monsters?filter=has_legendary_actions = true   # Legendary creatures
         *     GET /api/v1/monsters?filter=armor_class >= 18              # High AC tanks
         *     GET /api/v1/monsters?filter=speed_fly > 0                  # Flying creatures
         *     GET /api/v1/monsters?q=dragon&filter=challenge_rating >= 15 # Search + filter combined
         *     ```
         *
         *     **Filterable Fields by Data Type:**
         *
         *     **Integer Fields** (Operators: `=`, `!=`, `>`, `>=`, `<`, `<=`, `TO`):
         *     - `id` (int): Monster ID
         *     - `challenge_rating` (float): Challenge rating as numeric value (0.125 = 1/8, 0.25 = 1/4, 0.5 = 1/2, 1.0-30.0)
         *       - Examples: `challenge_rating = 5`, `challenge_rating >= 10`, `challenge_rating 5 TO 15`
         *       - Use case: Balance encounters by party level
         *     - `armor_class` (int): Natural or worn armor value (10-25 typical range)
         *       - Examples: `armor_class >= 18`, `armor_class < 15`
         *       - Use case: Tank enemies for melee-focused parties
         *     - `hit_points_average` (int): Average hit points (1-676 range, Ancient Red Dragon = 546)
         *       - Examples: `hit_points_average > 100`, `hit_points_average >= 200`
         *       - Use case: High-HP enemies for endurance encounters
         *     - `experience_points` (int): XP awarded on defeat (10-155000 range)
         *       - Examples: `experience_points >= 10000`, `experience_points < 1000`
         *       - Use case: Calculate encounter difficulty
         *     - `strength` (int): Strength ability score (1-30 range)
         *       - Examples: `strength >= 20`, `strength < 10`
         *       - Use case: Grappling/shoving challenges
         *     - `dexterity` (int): Dexterity ability score (1-30 range)
         *       - Examples: `dexterity >= 18`, `dexterity <= 8`
         *       - Use case: Initiative order and AC calculations
         *     - `constitution` (int): Constitution ability score (1-30 range)
         *       - Examples: `constitution >= 18`
         *       - Use case: Concentration save bonuses for spellcasters
         *     - `intelligence` (int): Intelligence ability score (1-30 range)
         *       - Examples: `intelligence >= 16`, `intelligence <= 3`
         *       - Use case: Investigation checks and INT saves
         *     - `wisdom` (int): Wisdom ability score (1-30 range)
         *       - Examples: `wisdom >= 18`, `wisdom < 10`
         *       - Use case: Perception checks and WIS saves
         *     - `charisma` (int): Charisma ability score (1-30 range)
         *       - Examples: `charisma >= 16`
         *       - Use case: Social encounters and CHA saves
         *     - `speed_walk` (int): Walking speed in feet (0-120 typical range)
         *       - Examples: `speed_walk >= 40`, `speed_walk = 0`
         *       - Use case: Chase scenes and tactical positioning
         *     - `speed_fly` (int): Flying speed in feet (0-120 typical range)
         *       - Examples: `speed_fly > 0`, `speed_fly >= 60`
         *       - Use case: Aerial combat encounters
         *     - `speed_swim` (int): Swimming speed in feet (0-90 typical range)
         *       - Examples: `speed_swim > 0`, `speed_swim >= 40`
         *       - Use case: Underwater encounters
         *     - `speed_burrow` (int): Burrowing speed in feet (0-40 typical range)
         *       - Examples: `speed_burrow > 0`
         *       - Use case: Underground or ambush encounters
         *     - `speed_climb` (int): Climbing speed in feet (0-40 typical range)
         *       - Examples: `speed_climb > 0`
         *       - Use case: Vertical terrain encounters
         *     - `passive_perception` (int): Passive Perception score (6-30 typical range)
         *       - Examples: `passive_perception >= 20`, `passive_perception < 12`
         *       - Use case: Stealth challenges and surprise rounds
         *     - `legendary_resistance_uses` (int): Number of legendary resistance uses per day (0-3)
         *       - Examples: `legendary_resistance_uses >= 1`
         *       - Use case: Boss fights requiring save-or-suck counters
         *
         *     **String Fields** (Operators: `=`, `!=`):
         *     - `slug` (string): URL-friendly monster identifier
         *       - Examples: `slug = ancient-red-dragon`, `slug != goblin`
         *     - `type` (string): Creature type (aberration, beast, celestial, construct, dragon, elemental, fey, fiend, giant, humanoid, monstrosity, ooze, plant, undead)
         *       - Examples: `type = dragon`, `type = undead`, `type != humanoid`
         *       - Use case: Ranger favored enemy, spell targeting
         *     - `size_code` (string): Size abbreviation (T=Tiny, S=Small, M=Medium, L=Large, H=Huge, G=Gargantuan)
         *       - Examples: `size_code = L`, `size_code = G`
         *       - Use case: Grapple size limits, space requirements
         *     - `size_name` (string): Full size name (Tiny, Small, Medium, Large, Huge, Gargantuan)
         *       - Examples: `size_name = Large`, `size_name = Gargantuan`
         *     - `alignment` (string): Alignment descriptor (lawful good, neutral evil, unaligned, etc.)
         *       - Examples: `alignment = lawful evil`, `alignment = unaligned`
         *       - Use case: Paladin/cleric detection spells
         *     - `armor_type` (string): Armor description (natural armor, plate armor, etc.)
         *       - Examples: `armor_type = natural armor`, `armor_type = plate armor`
         *
         *     **Response-Only Fields** (not filterable, included in response):
         *     - `languages` (string|null): Languages the monster speaks or understands
         *       - Formats: "Common, Elvish", "Deep Speech, telepathy 120 ft.", "understands Common but can't speak"
         *       - Null for creatures without language (e.g., most beasts)
         *
         *     **Boolean Fields** (Operators: `=`, `!=`, `IS NULL`, `EXISTS`):
         *     - `has_legendary_actions` (bool): Has legendary actions (not lair actions)
         *       - Examples: `has_legendary_actions = true`, `has_legendary_actions = false`
         *       - Use case: Epic boss fights requiring action economy
         *     - `has_lair_actions` (bool): Has lair actions (location-specific)
         *       - Examples: `has_lair_actions = true`
         *       - Use case: Home-field advantage encounters
         *     - `is_spellcaster` (bool): Can cast spells (129 monsters total)
         *       - Examples: `is_spellcaster = true`, `is_spellcaster = false`
         *       - Use case: Counterspell-ready encounters
         *     - `has_reactions` (bool): Has reaction abilities beyond opportunity attacks
         *       - Examples: `has_reactions = true`
         *       - Use case: Tactical combat with interrupt abilities
         *     - `has_legendary_resistance` (bool): Has Legendary Resistance trait (ignore failed saves)
         *       - Examples: `has_legendary_resistance = true`
         *       - Use case: Boss fights requiring sustained pressure
         *     - `has_magic_resistance` (bool): Has Magic Resistance trait (advantage on saves vs spells)
         *       - Examples: `has_magic_resistance = true`
         *       - Use case: Anti-caster encounters
         *     - `can_hover` (bool): Can hover while flying (immune to prone while flying)
         *       - Examples: `can_hover = true`
         *       - Use case: Aerial combat without fall risk
         *     - `is_npc` (bool): Named NPC rather than generic monster
         *       - Examples: `is_npc = true`, `is_npc = false`
         *       - Use case: Story characters vs random encounters
         *
         *     **Array Fields** (Operators: `IN`, `NOT IN`, `IS EMPTY`):
         *     - `source_codes` (array): Source book codes (MM, VGM, MTF, etc.)
         *       - Examples: `source_codes IN [MM, VGM]`, `source_codes NOT IN [UA]`
         *       - Use case: Campaign-specific monster selection
         *     - `tag_slugs` (array): Tag slugs for categorization (undead, fire-immune, shapechanger, etc.)
         *       - Examples: `tag_slugs IN [undead]`, `tag_slugs IN [fire-immune, cold-immune]`
         *       - Use case: Thematic encounters and elemental resistance
         *     - `spell_slugs` (array): Spell slugs this monster can cast (1,098 relationships for 129 spellcasters)
         *       - Examples: `spell_slugs IN [fireball]`, `spell_slugs IN [counterspell, dispel-magic]`
         *       - Use case: Counter-ready encounters and spell diversity
         *
         *     **Complex Filter Examples:**
         *     ```
         *     # Boss fights: CR 20+, legendary actions, legendary resistance
         *     ?filter=challenge_rating >= 20 AND has_legendary_actions = true AND has_legendary_resistance = true
         *
         *     # Tank enemies: High AC + High HP for melee-focused parties
         *     ?filter=armor_class >= 18 AND hit_points_average >= 150
         *
         *     # Flying spellcasters: Aerial combat with magic
         *     ?filter=speed_fly > 0 AND is_spellcaster = true
         *
         *     # Speed demons: Fast movement for chase scenes (CR 5-15)
         *     ?filter=speed_walk >= 50 AND challenge_rating >= 5 AND challenge_rating <= 15
         *
         *     # Legendary dragons: Epic dragon encounters
         *     ?filter=type = dragon AND has_legendary_actions = true
         *
         *     # Underwater bosses: High CR + swim speed
         *     ?filter=speed_swim > 0 AND challenge_rating >= 10
         *
         *     # Anti-magic tanks: Magic resistance + high saves
         *     ?filter=has_magic_resistance = true AND wisdom >= 16
         *
         *     # Fireball casters: Specific spell filtering
         *     ?filter=spell_slugs IN [fireball] AND challenge_rating >= 5
         *
         *     # Low-CR undead horde: Zombie/skeleton encounters
         *     ?filter=tag_slugs IN [undead] AND challenge_rating <= 1
         *
         *     # Elite guards: High stats across the board (CR 10+)
         *     ?filter=strength >= 18 AND dexterity >= 16 AND challenge_rating >= 10
         *     ```
         *
         *     **Use Cases:**
         *     - **Boss Fight Design**: Find legendary creatures with resistance mechanics
         *     - **CR Balancing**: Filter by challenge rating for party-appropriate encounters
         *     - **Thematic Encounters**: Use type/tag filters for campaign themes (undead, dragons, devils)
         *     - **Tactical Variety**: Combine ability scores and special traits for diverse combat
         *     - **Environmental Encounters**: Match monsters to terrain (swim/fly/burrow speeds)
         *     - **Spell Countermeasures**: Identify spellcasters with specific spells for strategic prep
         *
         *     **Operator Reference:**
         *     See `docs/MEILISEARCH-FILTER-OPERATORS.md` for comprehensive operator documentation.
         *
         *     **Query Parameters:**
         *     - `q` (string): Full-text search (searches name, description, type, alignment)
         *     - `filter` (string): Meilisearch filter expression
         *     - `sort_by` (string): name, armor_class, hit_points_average, challenge_rating, experience_points, speed_walk, strength, dexterity, passive_perception (default: name)
         *     - `sort_direction` (string): asc, desc (default: asc)
         *     - `per_page` (int): 1-100 (default: 15)
         *     - `page` (int): Page number (default: 1)
         */
        get: operations["monsters.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/monsters/{monster}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single monster
         * @description Returns detailed information about a specific monster including traits, actions,
         *     legendary actions, spellcasting, modifiers, conditions, and source citations.
         *     Supports selective relationship loading via the 'include' parameter.
         */
        get: operations["monsters.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/monsters/{monster}/spells": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all spells for a specific monster
         * @description Returns a collection of spells that the monster can cast, ordered by spell level then name.
         *     Returns an empty collection for non-spellcasters.
         *
         *     **Examples:**
         *     - Lich spells: `GET /api/v1/monsters/lich/spells` (26 spells from cantrips to 9th level)
         *     - Archmage spells: `GET /api/v1/monsters/archmage/spells` (22 spells)
         *     - Flameskull spells: `GET /api/v1/monsters/flameskull/spells` (10 spells up to 5th level)
         *
         *     **Spell Data Includes:**
         *     - Spell name, level, school, description
         *     - Casting time, range, components, duration
         *     - Damage types, saving throws, attack rolls
         *     - Concentration requirement, ritual casting
         *     - Source citations
         *
         *     **Use Cases:**
         *     - Combat Preparation: "What can this boss do?"
         *     - Spell List Comparison: Compare spellcasters for encounters
         *     - DM Reference: Quick lookup during gameplay
         *
         *     **Data Source:**
         *     Powered by SpellcasterStrategy which syncs 1,098 spell relationships
         *     across 129 spellcasting monsters with 100% match rate.
         */
        get: operations["monsters.spells"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/monster-types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all monster types
         * @description Returns distinct creature types from the monsters table. These are the 15 standard
         *     D&D 5e creature types used for classification, spells like "Protection from Evil",
         *     and ranger favored enemies.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/monster-types              # All creature types
         *     GET /api/v1/lookups/monster-types?q=fiend      # Search by name
         *     ```
         *
         *     **Standard D&D 5e Creature Types:**
         *     - **Classic:** Aberration, Beast, Celestial, Construct, Dragon
         *     - **Humanoid:** Humanoid, Giant, Fey, Elemental, Fiend
         *     - **Undead & Other:** Monstrosity, Ooze, Plant, Undead
         *
         *     **Query Parameters:**
         *     - `q` (string): Search by name (partial match)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - Ranger favored enemy selection (Favored Enemy class feature)
         *     - Cleric/Paladin spell targeting (Turn Undead, Protection from Evil, etc.)
         *     - Monster encounter filtering and encounter building
         *     - Spell effect verification (many spells target specific creature types)
         */
        get: operations["lookups.monster-types.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/optional-features": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all optional features
         * @description Returns a paginated list of D&D 5e optional features. Use `?filter=` for filtering and `?q=` for full-text search.
         *
         *     **Common Examples:**
         *     ```
         *     GET /api/v1/optional-features                                       # All optional features
         *     GET /api/v1/optional-features?filter=feature_type = eldritch_invocation  # Warlock invocations
         *     GET /api/v1/optional-features?filter=feature_type = metamagic        # Sorcerer metamagic
         *     GET /api/v1/optional-features?filter=class_slugs IN [warlock]       # Warlock features
         *     GET /api/v1/optional-features?filter=level_requirement <= 5          # Low-level features
         *     GET /api/v1/optional-features?filter=has_spell_mechanics = true      # Features with spell-like mechanics
         *     GET /api/v1/optional-features?q=agonizing                            # Full-text search for "agonizing"
         *     GET /api/v1/optional-features?q=fire&filter=feature_type = elemental_discipline  # Search + filter combined
         *     ```
         *
         *     **Filterable Fields by Data Type:**
         *
         *     **Integer Fields** (Operators: `=`, `!=`, `>`, `>=`, `<`, `<=`, `TO`):
         *     - `id` (int): Feature ID
         *     - `level_requirement` (int): Minimum character/class level required
         *       - Examples: `level_requirement = 5`, `level_requirement >= 9`, `level_requirement 1 TO 10`
         *     - `resource_cost` (int): Number of resource points required to use
         *       - Examples: `resource_cost = 2`, `resource_cost <= 3`
         *
         *     **String Fields** (Operators: `=`, `!=`):
         *     - `slug` (string): URL-friendly feature identifier
         *     - `feature_type` (string): Type of optional feature (eldritch_invocation, metamagic, etc.)
         *       - Examples: `feature_type = eldritch_invocation`, `feature_type = metamagic`
         *     - `resource_type` (string): Type of resource consumed (ki_points, sorcery_points, etc.)
         *       - Examples: `resource_type = ki_points`, `resource_type = sorcery_points`
         *
         *     **Boolean Fields** (Operators: `=`, `!=`, `IS NULL`, `EXISTS`):
         *     - `has_spell_mechanics` (bool): Feature has spell-like properties (casting time, range, etc.)
         *       - Examples: `has_spell_mechanics = true`, `has_spell_mechanics = false`
         *
         *     **Array Fields** (Operators: `IN`, `NOT IN`, `IS EMPTY`):
         *     - `class_slugs` (array): Class slugs that can use this optional feature
         *       - Examples: `class_slugs IN [warlock]`, `class_slugs IN [fighter, monk]`
         *     - `subclass_names` (array): Subclass names that can use this feature
         *       - Examples: `subclass_names IN [Battle Master]`, `subclass_names IN [Way of the Four Elements]`
         *     - `source_codes` (array): Source book codes (PHB, XGE, TCoE, etc.)
         *       - Examples: `source_codes IN [PHB]`, `source_codes NOT IN [UA]`
         *     - `tag_slugs` (array): Tag slugs categorizing features
         *       - Examples: `tag_slugs IN [damage]`, `tag_slugs IS EMPTY`
         *
         *     **Complex Filter Examples:**
         *     - Low-level Warlock invocations: `?filter=feature_type = eldritch_invocation AND level_requirement <= 5`
         *     - Monk elemental disciplines: `?filter=feature_type = elemental_discipline AND class_slugs IN [monk]`
         *     - Features with spell mechanics: `?filter=has_spell_mechanics = true`
         *     - Metamagic options: `?filter=feature_type = metamagic AND source_codes IN [PHB, TCoE]`
         *     - Fighter maneuvers: `?filter=feature_type = maneuver AND class_slugs IN [fighter]`
         *
         *     **Operator Reference:**
         *     See `docs/MEILISEARCH-FILTER-OPERATORS.md` for comprehensive operator documentation.
         *
         *     **Query Parameters:**
         *     - `q` (string): Full-text search (searches name, description, prerequisite_text)
         *     - `filter` (string): Meilisearch filter expression
         *     - `sort_by` (string): name, level_requirement, resource_cost, created_at, updated_at (default: name)
         *     - `sort_direction` (string): asc, desc (default: asc)
         *     - `per_page` (int): 1-100 (default: 15)
         *     - `page` (int): Page number (default: 1)
         */
        get: operations["optional-features.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/optional-features/{optionalFeature}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single optional feature
         * @description Returns detailed information about a specific optional feature including relationships
         *     like classes, sources, and tags. Supports selective relationship loading via the 'include' parameter.
         */
        get: operations["optional-features.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/optional-feature-types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all optional feature types
         * @description Returns all 8 D&D 5e optional feature types. These represent different kinds of class-specific
         *     choices available to characters during leveling (e.g., Eldritch Invocations for Warlocks,
         *     Fighting Styles for Fighters). Each type is associated with one or more classes.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/optional-feature-types              # All feature types
         *     GET /api/v1/lookups/optional-feature-types?q=fighting   # Search by name
         *     ```
         *
         *     **Optional Feature Types Reference:**
         *     - **Eldritch Invocation:** Warlock class features granting supernatural abilities
         *     - **Elemental Discipline:** Monk (Way of the Four Elements) subclass features
         *     - **Maneuver:** Fighter (Battle Master) subclass features for tactical combat
         *     - **Metamagic:** Sorcerer class features to modify spell casting
         *     - **Fighting Style:** Multiple classes (Fighter, Paladin, Ranger) combat specialization
         *     - **Artificer Infusion:** Artificer class features for magical item creation
         *     - **Rune:** Fighter (Rune Knight) subclass features granting magical runes
         *     - **Arcane Shot:** Fighter (Arcane Archer) subclass features using magical arrows
         *
         *     **Query Parameters:**
         *     - `q` (string): Search by name (partial match)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - **Character Building:** Filter optional features by type to help players choose features
         *     - **Class Feature Selection:** Show available feature types for a specific class
         *     - **Frontend Dropdowns:** Populate filter/search dropdowns in UI
         *     - **Feature Organization:** Group optional features by their mechanical type
         */
        get: operations["lookups.optional-feature-types.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/proficiency-types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all proficiency types
         * @description Returns D&D 5e proficiency types - the things characters can be trained in.
         *     Includes weapons, armor, tools, languages, skills, and saving throws.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/proficiency-types                           # All proficiencies
         *     GET /api/v1/lookups/proficiency-types?category=weapon           # All weapons
         *     GET /api/v1/lookups/proficiency-types?category=weapon&subcategory=martial  # Martial weapons only
         *     GET /api/v1/lookups/proficiency-types?category=armor            # All armor types
         *     GET /api/v1/lookups/proficiency-types?category=tool             # All tools
         *     GET /api/v1/lookups/proficiency-types?q=longsword               # Search by name
         *     ```
         *
         *     **Categories:**
         *     - **weapon:** All weapon proficiencies (subcategories: simple, martial)
         *     - **armor:** Light, Medium, Heavy, Shields
         *     - **tool:** Artisan's tools, gaming sets, musical instruments, thieves' tools
         *     - **language:** Common, Elvish, Dwarvish, exotic languages
         *     - **skill:** The 18 D&D skills (see /lookups/skills for details)
         *     - **saving-throw:** STR, DEX, CON, INT, WIS, CHA saves
         *
         *     **Query Parameters:**
         *     - `q` (string): Search proficiencies by name (partial match)
         *     - `category` (string): Filter by category (weapon, armor, tool, language, skill, saving-throw)
         *     - `subcategory` (string): Filter by subcategory (e.g., simple, martial for weapons)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - **Class Selection:** "Which classes get heavy armor?"  Filter by category=armor
         *     - **Multiclass Planning:** "What martial weapons can a Rogue use after Fighter dip?"
         *     - **Character Building:** Find which proficiencies your race/class/background grants
         *     - **Equipment Shopping:** Browse weapon proficiencies to know what you can use effectively
         */
        get: operations["lookups.proficiency-types.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/proficiency-types/{proficiencyType}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single proficiency type
         * @description Returns detailed information about a specific proficiency type.
         *     Proficiencies can be retrieved by ID, slug, or name.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/proficiency-types/42           # By ID
         *     GET /api/v1/lookups/proficiency-types/longsword    # By slug
         *     GET /api/v1/lookups/proficiency-types/Longsword    # By name
         *     ```
         *
         *     **Response includes:**
         *     - `id`, `name`, `slug`: Proficiency identification
         *     - `category`: Type of proficiency (weapon, armor, tool, language, skill)
         *     - `subcategory`: Sub-type (e.g., simple/martial for weapons)
         *     - `item`: Associated item details (for weapon/armor proficiencies)
         *
         *     **Related endpoints:**
         *     - `/api/v1/lookups/proficiency-types/{id}/classes` - Classes with this proficiency
         *     - `/api/v1/lookups/proficiency-types/{id}/races` - Races with this proficiency
         *     - `/api/v1/lookups/proficiency-types/{id}/backgrounds` - Backgrounds granting this proficiency
         */
        get: operations["lookups.proficiency-types.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/proficiency-types/{proficiencyType}/classes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all classes proficient with this proficiency type (weapon/armor/tool/skill/language)
         * @description **Examples:**
         *     ```bash
         *     # By numeric ID
         *     GET /api/v1/proficiency-types/flail/classes
         *
         *     # By name (most common for proficiencies)
         *     GET /api/v1/proficiency-types/Longsword/classes
         *     GET /api/v1/proficiency-types/Stealth/classes
         *     GET /api/v1/proficiency-types/Heavy%20Armor/classes
         *
         *     # With pagination
         *     GET /api/v1/proficiency-types/longsword/classes?per_page=25
         *     ```
         *
         *     **Common Proficiency Queries:**
         *     - **Martial Weapons:** Longsword, Greatsword, Longbow  Fighter, Paladin, Ranger, Barbarian
         *     - **Heavy Armor:** Plate, Chain Mail  Fighter, Paladin, Cleric (War/Forge domains)
         *     - **Skills:** Stealth  Rogue, Monk, Ranger | Perception  Ranger, Druid, Barbarian
         *     - **Tools:** Thieves' Tools  Rogue | Smith's Tools  Fighter (specific backgrounds)
         *     - **Languages:** Draconic  Sorcerer (Draconic Bloodline), Wizard
         *
         *     **Use Cases:**
         *     - **Multiclass Planning:** "Which classes are proficient with longswords?" (Fighter, Paladin, etc.)
         *     - **Build Optimization:** "I want heavy armor - which classes work?" (Fighter, Paladin)
         *     - **Skill Coverage:** "Which classes are proficient in Perception?" (Rangers, Druids, Barbarians)
         *     - **Tool Requirements:** "Which classes can use Thieves' Tools?" (Rogue + specific subclasses)
         *     - **Character Concept:** "I want a Draconic speaker - which classes learn Draconic?" (Sorcerer, Wizard)
         *
         *     **Proficiency Distribution (Typical):**
         *     - **Martial Weapons:** ~8-12 classes (primarily martial classes + some subclasses)
         *     - **Heavy Armor:** ~6-8 classes (Fighter, Paladin, Cleric domains)
         *     - **Skills (Stealth):** ~4-6 classes (Rogue, Monk, Ranger, Bard)
         *     - **Skills (Perception):** ~8-10 classes (most common skill proficiency)
         *     - **Tools:** ~1-3 classes (highly specialized, often background-dependent)
         *     - **Languages:** Varies widely (Common: all classes, Exotic: 1-2 classes)
         *
         *     **Character Building Advice:**
         *     - **Weapon Proficiency Gaps:** If your class lacks martial weapon proficiency, consider:
         *       - Feat: Weapon Master (gain 4 weapon proficiencies + +1 STR/DEX)
         *       - Multiclass: 1 level Fighter (all weapons + armor + Fighting Style)
         *       - Race: Elf/Dwarf variants grant specific weapon proficiencies
         *     - **Armor Proficiency Progression:** Light  Medium  Heavy (each tier requires feat/multiclass)
         *     - **Skill Proficiency Limits:** Classes get 2-4 skills at creation, backgrounds add 2 more
         *     - **Tool Proficiency Value:** Often background-dependent, but Thieves' Tools universally useful
         *
         *     **Query Tips:**
         *     - Use name routing for readability: `/proficiency-types/Longsword/classes` vs `/proficiency-types/42/classes`
         *     - Results are alphabetically sorted for consistent browsing
         *     - Includes base classes AND subclasses (e.g., Eldritch Knight Fighter counts separately)
         *     - Check `parent_class_id` in response to distinguish base vs subclass
         */
        get: operations["lookups.proficiency-types.classes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/proficiency-types/{proficiencyType}/races": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all races that have this proficiency type (weapon/armor/tool/skill/language/trait)
         * @description **Examples:**
         *     ```bash
         *     # By numeric ID
         *     GET /api/v1/proficiency-types/quarterstaff/races
         *
         *     # By name (recommended for readability)
         *     GET /api/v1/proficiency-types/Elvish/races
         *     GET /api/v1/proficiency-types/Longsword/races
         *     GET /api/v1/proficiency-types/Darkvision/races
         *
         *     # With pagination
         *     GET /api/v1/proficiency-types/dwarven-resilience/races?per_page=10
         *     ```
         *
         *     **Common Racial Proficiency Queries:**
         *     - **Languages:** Elvish  Elf, Half-Elf | Dwarvish  Dwarf, Duergar | Draconic  Dragonborn
         *     - **Weapons:** Longsword, Shortsword  Elf variants | Battleaxe, Warhammer  Dwarf variants
         *     - **Tools:** Smith's Tools  Mountain Dwarf | Tinker's Tools  Rock Gnome
         *     - **Traits:** Darkvision  Dwarf, Elf, Tiefling, Half-Orc (~60% of races)
         *     - **Armor:** Light/Medium Armor  Specific racial variants (rare, usually Mountain Dwarf)
         *
         *     **Use Cases:**
         *     - **Language Planning:** "Which races speak Elvish?" (Elf, Half-Elf, High Elf)
         *     - **Weapon Synergies:** "I want longsword proficiency from race - which races work?" (Elves)
         *     - **Tool Proficiencies:** "Which races get Smith's Tools?" (Mountain Dwarf)
         *     - **Trait Coverage:** "Which races have Darkvision?" (Dwarf, Elf, Tiefling, Gnome, etc.)
         *     - **Build Optimization:** "I want a Fighter with elven weapon training - which elf subrace?"
         *
         *     **Proficiency Distribution (Typical):**
         *     - **Languages:** Common (all races), Elvish (~4 races), Dwarvish (~3 races), Draconic (~2 races)
         *     - **Weapons:** Elf variants (~3-4 races for longsword/bow), Dwarf variants (~2-3 for axes/hammers)
         *     - **Tools:** ~1-2 races per tool type (highly specialized)
         *     - **Darkvision:** ~12-15 races out of ~30 total (very common trait)
         *     - **Skills:** Rare as racial proficiencies (usually background-dependent)
         *
         *     **Character Building Advice:**
         *     - **Stacking Proficiencies:** Elf Fighter = Longsword prof from race + all martial weapons from class
         *     - **Unique Combinations:** Mountain Dwarf Wizard = Medium armor prof (normally Wizard has none!)
         *     - **Language Optimization:** Pick race based on campaign setting (Elvish for Faerun, Draconic for dragonlands)
         *     - **Darkvision Value:** Critical in dungeon-heavy campaigns, less useful in urban/outdoor settings
         *
         *     **Query Tips:**
         *     - Use name routing: `/proficiency-types/Elvish/races` vs `/proficiency-types/7/races`
         *     - Results include base races AND subraces (e.g., High Elf, Wood Elf count separately)
         *     - Check `parent_race_id` in response to distinguish base race vs subrace
         *     - Results alphabetically sorted for consistent browsing
         */
        get: operations["lookups.proficiency-types.races"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/proficiency-types/{proficiencyType}/backgrounds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all backgrounds that grant this proficiency type (skill/tool/language/equipment)
         * @description **Examples:**
         *     ```bash
         *     # By numeric ID
         *     GET /api/v1/proficiency-types/dagger/backgrounds
         *
         *     # By name (recommended for clarity)
         *     GET /api/v1/proficiency-types/Stealth/backgrounds
         *     GET /api/v1/proficiency-types/Thieves%27%20Tools/backgrounds
         *     GET /api/v1/proficiency-types/Deception/backgrounds
         *
         *     # With pagination
         *     GET /api/v1/proficiency-types/insight/backgrounds?per_page=15
         *     ```
         *
         *     **Common Background Proficiency Queries:**
         *     - **Skills (Social):** Deception  Charlatan, Criminal | Persuasion  Noble, Guild Artisan
         *     - **Skills (Stealth):** Stealth  Criminal, Urchin, Spy | Sleight of Hand  Criminal, Entertainer
         *     - **Skills (Knowledge):** Insight  Acolyte, Sage, Hermit | Investigation  Sage, City Watch
         *     - **Tools:** Thieves' Tools  Criminal, Urchin | Gaming Set  Gambler, Sailor
         *     - **Languages:** Most backgrounds grant 1-2 language choices (player picks from standard list)
         *
         *     **Use Cases:**
         *     - **Skill Coverage:** "I need Stealth but my class doesn't have it - which backgrounds work?" (Criminal, Urchin)
         *     - **Tool Requirements:** "Which backgrounds grant Thieves' Tools?" (Criminal, Urchin)
         *     - **Role-Playing Synergy:** "I'm playing a con artist - which backgrounds fit?" (Charlatan, Criminal)
         *     - **Multiclass Optimization:** "I need Investigation for my Detective build" (Sage, City Watch)
         *     - **Campaign Fit:** "We need a diplomat - which backgrounds grant Persuasion?" (Noble, Guild Artisan)
         *
         *     **Proficiency Distribution (Typical):**
         *     - **Skills (Stealth):** ~3-4 backgrounds (Criminal, Urchin, Spy, Urban Bounty Hunter)
         *     - **Skills (Persuasion):** ~4-5 backgrounds (Noble, Guild Artisan, Courtier, Entertainer)
         *     - **Skills (Insight):** ~5-6 backgrounds (Acolyte, Sage, Hermit, Folk Hero)
         *     - **Tools (Thieves' Tools):** ~2 backgrounds (Criminal, Urchin)
         *     - **Tools (Artisan's Tools):** ~8-10 backgrounds (Guild Artisan variants for each tool type)
         *     - **Languages:** Nearly all backgrounds grant 1-2 language choices
         *
         *     **Character Building Advice:**
         *     - **Skill Proficiency Overlap:** If background + class both grant same skill, you can swap ONE background skill
         *     - **Tool Proficiency Value:** Thieves' Tools (lockpicking) > other tools for dungeon delving
         *     - **Language Strategy:** Pick languages based on campaign (Undercommon for Underdark, Celestial for holy campaigns)
         *     - **Background Variants:** Many backgrounds have official variants (e.g., Criminal  Spy, same proficiencies)
         *
         *     **Typical Background Combinations:**
         *     - **Rogue + Criminal:** Double Stealth prof  swap to Perception or Insight
         *     - **Fighter + Soldier:** Double Athletics prof  swap to Intimidation or Survival
         *     - **Wizard + Sage:** Triple Intelligence skill coverage (Investigation, Arcana, History)
         *     - **Cleric + Acolyte:** Perfect thematic fit (Insight, Religion, holy proficiencies)
         *
         *     **Query Tips:**
         *     - Use name routing for readability: `/proficiency-types/Stealth/backgrounds` vs `/proficiency-types/12/backgrounds`
         *     - Results alphabetically sorted for consistent navigation
         *     - All backgrounds are base-level (no "sub-backgrounds" like races/classes have)
         *     - Check background description for thematic fit beyond mechanical proficiencies
         */
        get: operations["lookups.proficiency-types.backgrounds"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/races": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all races and subraces
         * @description Returns a paginated list of 115 D&D 5e races and subraces. Use `?filter=` for filtering and `?q=` for full-text search.
         *
         *     **Common Examples:**
         *     ```
         *     GET /api/v1/races                                              # All races
         *     GET /api/v1/races?filter=ability_int_bonus >= 2                # Wizard races (High Elf, Gnome)
         *     GET /api/v1/races?filter=ability_dex_bonus >= 2                # Rogue races (Wood Elf, Lightfoot Halfling)
         *     GET /api/v1/races?filter=ability_str_bonus >= 1 AND ability_con_bonus >= 1  # Barbarian races
         *     GET /api/v1/races?filter=speed >= 35                           # Fast races (35 ft)
         *     GET /api/v1/races?filter=tag_slugs IN [darkvision]             # Races with darkvision
         *     GET /api/v1/races?q=elf&filter=ability_dex_bonus >= 1          # Search + filter combined
         *     ```
         *
         *     **Filterable Fields by Data Type:**
         *
         *     **Integer Fields** (Operators: `=`, `!=`, `>`, `>=`, `<`, `<=`, `TO`):
         *     - `id` (int): Race ID
         *     - `speed` (int): Base walking speed in feet (typically 25-35)
         *       - Examples: `speed = 30`, `speed >= 35`, `speed 25 TO 35`
         *     - **`ability_str_bonus` (0-2)**: Strength bonus for martial characters
         *       - Examples: `ability_str_bonus >= 2` (Mountain Dwarf, Dragonborn), `ability_str_bonus >= 1` (Half-Orc)
         *     - **`ability_dex_bonus` (0-2)**: Dexterity bonus for rogues, rangers, monks
         *       - Examples: `ability_dex_bonus >= 2` (Wood Elf, Lightfoot Halfling, Goblin), `ability_dex_bonus = 1`
         *     - **`ability_con_bonus` (0-2)**: Constitution bonus for durability
         *       - Examples: `ability_con_bonus >= 2` (Hill Dwarf, Stout Halfling), `ability_con_bonus >= 1`
         *     - **`ability_int_bonus` (0-2)**: Intelligence bonus for wizards, artificers
         *       - Examples: `ability_int_bonus >= 2` (High Elf, Gnome), `ability_int_bonus >= 1` (Tiefling)
         *     - **`ability_wis_bonus` (0-2)**: Wisdom bonus for clerics, druids, rangers
         *       - Examples: `ability_wis_bonus >= 2` (Firbolg, Kalashtar), `ability_wis_bonus >= 1` (Wood Elf, Hill Dwarf)
         *     - **`ability_cha_bonus` (0-2)**: Charisma bonus for bards, sorcerers, warlocks, paladins
         *       - Examples: `ability_cha_bonus >= 2` (Half-Elf, Tiefling, Dragonborn), `ability_cha_bonus >= 1` (Drow, Changeling)
         *
         *     **String Fields** (Operators: `=`, `!=`):
         *     - `slug` (string): URL-friendly identifier
         *       - Examples: `slug = high-elf`, `slug != human`
         *     - `size_code` (string): Size code (T, S, M, L, H, G)
         *       - Examples: `size_code = M`, `size_code = S`
         *     - `size_name` (string): Size name (Tiny, Small, Medium, Large, Huge, Gargantuan)
         *       - Examples: `size_name = Medium`, `size_name = Small`
         *     - `parent_race_name` (string): Parent race name for subraces
         *       - Examples: `parent_race_name = Elf`, `parent_race_name = Dwarf`
         *
         *     **Boolean Fields** (Operators: `=`, `!=`, `IS NULL`, `EXISTS`):
         *     - `is_subrace` (bool): Whether this is a subrace
         *       - Examples: `is_subrace = true`, `is_subrace = false`
         *     - `has_innate_spells` (bool): Whether race grants innate spellcasting
         *       - Examples: `has_innate_spells = true`, `has_innate_spells = false`
         *
         *     **Array Fields** (Operators: `IN`, `NOT IN`, `IS EMPTY`):
         *     - `source_codes` (array): Source book codes (PHB, XGE, TCoE, etc.)
         *       - Examples: `source_codes IN [PHB, XGE]`, `source_codes NOT IN [UA]`
         *     - `tag_slugs` (array): Trait tags (darkvision, fey-ancestry, innate-spellcasting, etc.)
         *       - Examples: `tag_slugs IN [darkvision]`, `tag_slugs IN [fey-ancestry, innate-spellcasting]`
         *     - `spell_slugs` (array): Innate spell slugs (13 races have innate spells)
         *       - Examples: `spell_slugs IN [misty-step]`, `spell_slugs IN [dancing-lights, faerie-fire, darkness]`
         *
         *     **Complex Filter Examples:**
         *     - Wizard races: `?filter=ability_int_bonus >= 2`
         *     - Barbarian races: `?filter=ability_str_bonus >= 1 AND ability_con_bonus >= 1`
         *     - Rogue/Dex races: `?filter=ability_dex_bonus >= 2`
         *     - Charisma casters: `?filter=ability_cha_bonus >= 2`
         *     - Fast darkvision races: `?filter=speed >= 35 AND tag_slugs IN [darkvision]`
         *     - Races with teleportation: `?filter=spell_slugs IN [misty-step]`
         *     - Medium-sized races with +2 Dex: `?filter=size_code = M AND ability_dex_bonus >= 2`
         *     - Base races only: `?filter=is_subrace = false`
         *     - Subraces of Elf: `?filter=parent_race_name = Elf`
         *
         *     **Operator Reference:**
         *     See `docs/MEILISEARCH-FILTER-OPERATORS.md` for comprehensive operator documentation.
         *
         *     **Query Parameters:**
         *     - `q` (string): Full-text search (searches name, size name, parent race name)
         *     - `filter` (string): Meilisearch filter expression
         *     - `sort_by` (string): name, speed, created_at, updated_at (default: name)
         *     - `sort_direction` (string): asc, desc (default: asc)
         *     - `per_page` (int): 1-100 (default: 15)
         *     - `page` (int): Page number (default: 1)
         */
        get: operations["races.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/races/{race}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single race
         * @description Returns detailed information about a specific race or subrace including parent race,
         *     subraces, ability modifiers, proficiencies, traits, languages, and spells.
         *     Supports selective relationship loading via the 'include' parameter.
         */
        get: operations["races.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/races/{race}/spells": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get innate spells for a race
         * @description Returns all innate spells granted by a specific race or subrace,
         *     sorted by spell level and then alphabetically. Includes spell school
         *     information for filtering and categorization.
         *
         *     **Use Cases:**
         *     - Character creation: View all spells this race grants
         *     - Build planning: Compare innate spellcasting between races
         *     - Rules reference: Quick lookup of racial spell access
         *     - API integration: Programmatic access to racial spell lists
         *
         *     **Examples of Racial Innate Spells:**
         *     - Drow: Dancing Lights (0), Faerie Fire (1), Darkness (2)
         *     - Tiefling: Thaumaturgy (0), Hellish Rebuke (1), Darkness (2)
         *     - High Elf: 1 wizard cantrip (player's choice)
         *     - Forest Gnome: Minor Illusion (0)
         */
        get: operations["races.spells"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/rarities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all item rarities
         * @description Returns distinct rarities from the items table. These represent the relative
         *     power and availability of magic items in D&D 5e, ordered from Common to Artifact.
         *
         *     **Magic Item Rarity Scale (D&D 5e Official):**
         *     - **Common** - Minor conveniences, cost 50-100 gp, no attunement
         *     - **Uncommon** - Low-level utility, cost 101-500 gp, optional attunement
         *     - **Rare** - Mid-level power, cost 501-5,000 gp, often requires attunement (levels 5-10)
         *     - **Very Rare** - High-level abilities, cost 5,001-50,000 gp, usually requires attunement (levels 11-16)
         *     - **Legendary** - Powerful artifacts, cost 50,001+ gp, requires attunement (levels 17+)
         *     - **Artifact** - World-defining items, priceless, major campaign implications
         *
         *     **Common Examples:**
         *     ```
         *     GET /api/v1/lookups/rarities              # All rarities (6 standard D&D rarities)
         *     ```
         *
         *     **Character Level Guidelines:**
         *     - Level 1-4: Common, Uncommon items
         *     - Level 5-10: Uncommon, Rare items
         *     - Level 11-16: Rare, Very Rare items
         *     - Level 17+: Legendary, Artifact items
         *
         *     **Use Cases:**
         *     - Magic item shop filtering by character power level
         *     - Treasure hoard generation following DMG guidelines
         *     - Campaign loot planning and balance
         *     - Item rarity-based access control
         */
        get: operations["lookups.rarities.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Global search across all D&D entities
         * @description Search simultaneously across spells, items, races, classes, backgrounds, feats, and monsters.
         *     Returns grouped results with relevance ranking powered by Meilisearch. Perfect for implementing
         *     universal search bars, type-ahead autocomplete, and cross-entity content discovery.
         *
         *     **Basic Examples:**
         *     - Search everything: `GET /api/v1/search?q=fire`
         *     - Search by keyword: `GET /api/v1/search?q=dragon` (finds Dragon spells, Dragon race, Dragon monsters)
         *     - Search specific types: `GET /api/v1/search?q=healing&types=spells,items`
         *     - Limit results per type: `GET /api/v1/search?q=magic&limit=10` (10 per entity type)
         *     - Debug mode: `GET /api/v1/search?q=test&debug=true` (includes execution time, Meilisearch host)
         *
         *     **Type-Specific Search Examples:**
         *     - Spells only: `GET /api/v1/search?q=fireball&types=spells`
         *     - Monsters only: `GET /api/v1/search?q=ancient&types=monsters`
         *     - Items + Equipment: `GET /api/v1/search?q=sword&types=items`
         *     - Character options: `GET /api/v1/search?q=elf&types=races,classes,backgrounds,feats`
         *     - Combat content: `GET /api/v1/search?q=attack&types=spells,items,monsters`
         *
         *     **Multi-Type Search Examples:**
         *     - Fire-themed content: `GET /api/v1/search?q=fire&types=spells,monsters,items` (Fire spells, fire-breathing monsters, fire resistance items)
         *     - Healing options: `GET /api/v1/search?q=healing&types=spells,items,classes` (Healing spells, potions, Cleric)
         *     - Stealth builds: `GET /api/v1/search?q=stealth&types=spells,items,backgrounds,feats` (Invisibility, Cloak of Elvenkind, Criminal, Skulker)
         *     - Undead encounters: `GET /api/v1/search?q=undead&types=monsters,spells,items` (Zombie, Turn Undead, Holy Water)
         *
         *     **Fuzzy Matching Examples (Typo-Tolerant):**
         *     - "firebll"  finds "Fireball" (1 character typo)
         *     - "ligt"  finds "Light" (1 character typo)
         *     - "elv"  finds "Elf", "Elven", "Elvish" (prefix matching)
         *     - "wizar"  finds "Wizard" (partial word matching)
         *
         *     **Use Cases:**
         *     - **Universal Search Bar**: Single endpoint for navbar/header search across entire D&D compendium
         *     - **Type-Ahead Autocomplete**: Fast fuzzy matching with <50ms average response time
         *     - **Content Discovery**: "What D&D content relates to dragons?" (spells, monsters, races, items)
         *     - **Character Building**: Find related spells, items, and feats for specific builds
         *     - **DM Encounter Prep**: Search for monsters + spells + items for themed encounters
         *     - **Rules Lookup**: Quick reference across all entity types ("What gives advantage?")
         *     - **Mobile Apps**: Lightweight endpoint for cross-entity search on mobile devices
         *     - **API Exploration**: Discover available content before querying specific endpoints
         *
         *     **Query Parameters:**
         *     - `q` (string, required): Search query term (min 2 characters)
         *     - `types` (string, optional): Comma-separated entity types to search (default: all)
         *       - Valid types: `spells`, `items`, `monsters`, `races`, `classes`, `backgrounds`, `feats`
         *     - `limit` (int, optional): Maximum results per entity type (default: 20, max: 100)
         *     - `debug` (bool, optional): Include debug info (execution time, Meilisearch host)
         *
         *     **Response Structure:**
         *     ```json
         *     {
         *       "data": {
         *         "query": "fire",
         *         "types_searched": ["spells", "items", "monsters", "races", "classes", "backgrounds", "feats"],
         *         "limit_per_type": 20,
         *         "total_results": 42,
         *         "spells": [...],      // Array of spell objects
         *         "items": [...],       // Array of item objects
         *         "monsters": [...],    // Array of monster objects
         *         "races": [...],       // Array of race objects
         *         "classes": [...],     // Array of class objects
         *         "backgrounds": [...], // Array of background objects
         *         "feats": [...]        // Array of feat objects
         *       }
         *     }
         *     ```
         *
         *     **Performance:**
         *     - Average response time: <50ms for most queries
         *     - p95 response time: <100ms
         *     - Searches 3,600+ documents across 7 entity types
         *     - Powered by Meilisearch for typo-tolerance and relevance ranking
         *
         *     **Relevance Ranking:**
         *     Results are sorted by Meilisearch relevance score, which considers:
         *     - Exact matches (highest priority)
         *     - Prefix matches (e.g., "fire" matches "Fireball")
         *     - Typo tolerance (1-2 character differences)
         *     - Field importance (name > description)
         *     - Word proximity (closer words rank higher)
         *
         *     **Data Source:**
         *     - 477 spells, 516 items, 598 monsters, 131 classes
         *     - Races, subraces, backgrounds, feats from all D&D 5e sourcebooks
         *     - Indexed in Meilisearch for fast fuzzy search
         *     - Falls back to database LIKE queries if Meilisearch unavailable
         *
         *     **Example Frontend Implementation:**
         *     ```javascript
         *     // Universal search bar with type-ahead
         *     const searchAll = async (query) => {
         *       const response = await fetch(`/api/v1/search?q=${query}&limit=5`);
         *       const data = await response.json();
         *       return data.data; // { spells: [...], items: [...], ... }
         *     };
         *
         *     // Category-specific search (e.g., spell picker)
         *     const searchSpells = async (query) => {
         *       const response = await fetch(`/api/v1/search?q=${query}&types=spells&limit=10`);
         *       const data = await response.json();
         *       return data.data.spells; // Array of matching spells
         *     };
         *     ```
         *
         *     See `docs/API-EXAMPLES.md` for comprehensive usage examples and integration patterns.
         */
        get: operations["search"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/sizes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all creature sizes
         * @description Returns the 6 D&D 5e creature size categories used to classify all creatures, races, and monsters.
         *     Size determines space occupied, grappling rules, mounted combat eligibility, and movement constraints.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/sizes              # All 6 size categories
         *     GET /api/v1/lookups/sizes?q=medium     # Search by name
         *     ```
         *
         *     **Size Categories:**
         *     - **Tiny (T):** Space: 2.5ft  2.5ft ( square) | Examples: Imp, Sprite, Flying Snake
         *     - **Small (S):** Space: 5ft  5ft (1 square) | Examples: Halfling, Gnome, Goblin, Kobold
         *     - **Medium (M):** Space: 5ft  5ft (1 square) | Examples: Human, Elf, Dwarf, Orc (most races)
         *     - **Large (L):** Space: 10ft  10ft (4 squares) | Examples: Ogre, Centaur, Young Dragon
         *     - **Huge (H):** Space: 15ft  15ft (9 squares) | Examples: Giant, Adult Dragon, Purple Worm
         *     - **Gargantuan (G):** Space: 20ft  20ft (16 squares) | Examples: Ancient Dragon, Kraken, Tarrasque
         *
         *     **Combat & Gameplay Implications:**
         *     - **Space Control:** Larger creatures occupy more squares and control more battlefield area
         *     - **Grappling:** Can only grapple creatures within one size category (Medium grapples Small/Medium/Large)
         *     - **Mounted Combat:** Mount must be one size larger than rider (Small rides Medium, Medium rides Large)
         *     - **Heavy Weapons:** Small creatures have disadvantage on attack rolls with Heavy weapons
         *     - **Movement:** Larger creatures struggle with narrow corridors and standard doorways (5ft wide)
         *     - **Squeezing:** Creatures can squeeze through spaces half their width at half speed with disadvantage
         *
         *     **Query Parameters:**
         *     - `q` (string): Search by name (partial match)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - **Race Selection:** "I want a Small race for mounted combat and stealth builds"
         *     - **Grappling Builds:** "Which size allows grappling the widest range of enemies?" (Medium)
         *     - **Encounter Design:** "What space requirements do I need for a Large boss fight?" (10ft  10ft minimum)
         *     - **Mount Planning:** "My Small Halfling needs a Medium mount - what are the options?" (Pony, Wolf, Mastiff)
         *     - **Dungeon Navigation:** "Will a Large PC fit through standard 5ft doors?" (Yes, but squeezing)
         */
        get: operations["lookups.sizes.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/sizes/{size}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single size category
         * @description Returns detailed information about a specific D&D 5e size category.
         *     Size categories can be retrieved by ID, code (T/S/M/L/H/G), or name.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/sizes/1              # By ID
         *     GET /api/v1/lookups/sizes/M              # By code (Medium)
         *     GET /api/v1/lookups/sizes/medium         # By name
         *     GET /api/v1/lookups/sizes/S              # By code (Small)
         *     ```
         *
         *     **Response includes:**
         *     - `id`, `code`, `name`: Size identification (e.g., 3, "M", "Medium")
         *     - Relationships available: `/sizes/{id}/races`, `/sizes/{id}/monsters`
         */
        get: operations["lookups.sizes.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/sizes/{size}/races": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all races of this size category
         * @description Returns a paginated list of playable and monster races that are of the specified size.
         *     Size affects combat mechanics, grappling rules, mounted combat, and dungeon navigation.
         *
         *     **Examples:**
         *     ```bash
         *     # By code (T=Tiny, S=Small, M=Medium, L=Large, H=Huge, G=Gargantuan)
         *     GET /api/v1/sizes/S/races      # Small races
         *     GET /api/v1/sizes/M/races      # Medium races
         *     GET /api/v1/sizes/T/races?per_page=25
         *     ```
         *
         *     **Size Categories & Common Races:**
         *     - **Tiny (1):** No playable races, some monster templates
         *     - **Small (2):** Halfling, Gnome, Kobold, Goblin (~22 races total)
         *       - Popular for Rogue/Ranger builds (stealth bonus)
         *       - Can ride Medium creatures as mounts
         *       - Disadvantage with Heavy weapons
         *     - **Medium (3):** Human, Elf, Dwarf, Half-Elf, Tiefling, most races (~93 races total)
         *       - Standard size for most player characters
         *       - No size-based combat restrictions
         *       - Can be mounts for Small creatures
         *     - **Large (4):** Centaur, Minotaur (rare playable races)
         *       - Powerful melee builds
         *       - Cannot fit through standard doors (5ft width)
         *       - Can grapple Huge creatures
         *     - **Huge (5) & Gargantuan (6):** Monster-only sizes (no playable races)
         *
         *     **Use Cases:**
         *     - **Race selection:** "I want to play a Small character for stealth and mounted combat builds"
         *     - **Mechanical planning:** Small races can ride Medium creatures (find a wolf companion!)
         *     - **Grappling optimization:** Can only grapple targets within one size category of you
         *     - **Dungeon design awareness:** Small races fit through 2.5ft spaces, Large+ struggle with doors
         *     - **Party composition:** Ensure size diversity for tactical advantages
         *
         *     **Combat Mechanics by Size:**
         *     - **Small creatures:**
         *       - Disadvantage on attack rolls with Heavy weapons (greatsword, maul)
         *       - Can move through spaces of Medium or larger creatures (squeeze rules)
         *       - Can ride Medium creatures as mounts (mounted combat synergy)
         *       - Take up 5ft  5ft space (same as Medium)
         *       - Can fit through 2.5ft wide spaces without squeezing
         *     - **Medium creatures:**
         *       - No size-based restrictions (standard baseline)
         *       - Can grapple Small to Large creatures
         *       - Can serve as mounts for Small creatures
         *       - Take up 5ft  5ft space
         *     - **Large+ creatures:**
         *       - Take up 10ft  10ft space (Large), 15ft  15ft (Huge), 20ft  20ft (Gargantuan)
         *       - Reach weapons extend control zones
         *       - Cannot fit through standard 5ft doorways
         *       - Powerful grappling potential (can grapple Huge creatures as Large)
         *
         *     **Grappling Rules by Size:**
         *     - Can only grapple creatures within **one size category** of you
         *     - Small creature can grapple: Tiny or Small
         *     - Medium creature can grapple: Small, Medium, or Large
         *     - Large creature can grapple: Medium, Large, or Huge
         *     - **Use case:** "Which Small races can I play if I want to grapple Small enemies?"
         *
         *     **Mounted Combat Rules:**
         *     - Mount must be **one size category larger** than rider
         *     - Small creatures can ride Medium mounts (ponies, wolves, mastiffs)
         *     - Medium creatures can ride Large mounts (horses, camels, elk)
         *     - **Use case:** "Which Small races can I play for a mounted Rogue build?"
         *
         *     **Space & Movement:**
         *     - Small/Medium: 5ft  5ft space (1 square)
         *     - Large: 10ft  10ft space (4 squares)
         *     - Huge: 15ft  15ft space (9 squares)
         *     - Gargantuan: 20ft  20ft space (16 squares)
         *     - **Squeezing:** Can squeeze through spaces half your width at half speed (Small through 1.25ft)
         */
        get: operations["lookups.sizes.races"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/sizes/{size}/monsters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all monsters of this size category
         * @description Returns a paginated list of monsters that are of the specified size.
         *     Size affects encounter balance, tactics, space control, and environmental challenges.
         *
         *     **Examples:**
         *     ```bash
         *     # By code (T=Tiny, S=Small, M=Medium, L=Large, H=Huge, G=Gargantuan)
         *     GET /api/v1/sizes/T/monsters     # Tiny monsters
         *     GET /api/v1/sizes/L/monsters     # Large monsters
         *     GET /api/v1/sizes/H/monsters?per_page=25  # Huge monsters
         *     ```
         *
         *     **Size Categories & Common Monsters:**
         *     - **Tiny (1):** Sprites, Imps, Flying Snakes, Cranium Rats (~55 monsters)
         *       - Often swarms or scouts
         *       - High stealth potential
         *       - Low HP, used in large groups
         *       - CR range: 0-4 (some exceptions)
         *     - **Small (2):** Goblins, Kobolds, Pixies, Stirges (~49 monsters)
         *       - Common low-level threats
         *       - Pack tactics frequent
         *       - CR range: 0-8
         *     - **Medium (3):** Humans, Orcs, Zombies, Bugbears, most humanoids (~280 monsters)
         *       - Largest category (47% of all monsters)
         *       - CR range: 0-30 (Ancient Vampire)
         *       - Includes iconic threats like Beholders, Mind Flayers
         *     - **Large (4):** Ogres, Ettins, Young Dragons, Owlbears (~151 monsters)
         *       - Serious combat threats
         *       - 10ft reach common
         *       - CR range: 1-22 (Adult Dragons)
         *     - **Huge (5):** Giants, Adult Dragons, Purple Worms (~47 monsters)
         *       - Boss-tier enemies
         *       - Space control dominance
         *       - CR range: 4-24 (Ancient Dragons)
         *     - **Gargantuan (6):** Ancient Dragons, Krakens, Tarrasque (~16 monsters)
         *       - Legendary encounters
         *       - World-ending threats
         *       - CR range: 10-30 (Tarrasque)
         *
         *     **Use Cases:**
         *     - **Encounter building:** "I need Large creatures for a CR 5 encounter in a 30ft  30ft room"
         *     - **Tactical planning:** "Which Huge monsters can't fit through this 10ft tunnel?" (All of them!)
         *     - **Boss selection:** "Give me all Gargantuan monsters for a campaign finale" (16 options)
         *     - **Environmental challenges:** "Which monsters can squeeze through tight spaces?" (Tiny/Small)
         *     - **Space control:** "Which Large monsters have 10ft reach?" (filter by size, check actions)
         *
         *     **Combat Tactics by Monster Size:**
         *     - **Tiny/Small monsters:**
         *       - Use in swarms (5-10 creatures)
         *       - Focus on mobility and stealth
         *       - Gang up for Pack Tactics advantage
         *       - Easy to hit (low AC typical) but numerous
         *     - **Medium monsters:**
         *       - Standard 5ft reach, 5ft  5ft space
         *       - Most versatile size for varied tactics
         *       - Can navigate any terrain
         *     - **Large monsters:**
         *       - Often 10ft reach (control 24 squares!)
         *       - Block doorways and corridors
         *       - 4 space of Medium (tactical positioning critical)
         *       - Grapple up to Huge creatures
         *     - **Huge monsters:**
         *       - 15ft reach possible (control 48 squares!)
         *       - Dominate battlefield positioning
         *       - Cannot fit through 10ft doors
         *       - Legendary boss-tier threats
         *     - **Gargantuan monsters:**
         *       - 20ft reach typical (control 80+ squares!)
         *       - Outdoor-only encounters (can't fit in dungeons)
         *       - Siege-scale threats
         *       - Legendary Actions almost guaranteed
         *
         *     **Encounter Design Considerations:**
         *     - **Space required:** Large needs 10ft  10ft, Huge needs 15ft  15ft, Gargantuan needs 20ft  20ft
         *     - **Reach zones:** Large creatures with 10ft reach control massive areas (don't bunch up!)
         *     - **Terrain challenges:** Huge+ creatures can't fit through standard dungeon corridors (10ft wide)
         *     - **Grappling threat:** Large+ monsters can grapple and restrain Medium PCs easily
         *     - **Action economy:** Use multiple Small/Medium monsters vs single Large+ for balance
         *
         *     **CR Distribution by Size:**
         *     - Tiny: Mostly CR 0-4 (swarm fodder, scouts)
         *     - Small: CR 0-8 (goblinoids, common threats)
         *     - Medium: CR 0-30 (full range, most versatile)
         *     - Large: CR 1-22 (mid-tier bosses, dragons)
         *     - Huge: CR 4-24 (high-tier bosses, ancient dragons)
         *     - Gargantuan: CR 10-30 (legendary encounters only)
         *
         *     **Environmental Constraints:**
         *     - **Standard door:** 5ft wide (Large+ squeeze, Huge+ cannot fit)
         *     - **Wide corridor:** 10ft wide (Huge+ squeeze, Gargantuan cannot fit)
         *     - **Cavern/outdoor:** Only limitation is Gargantuan (20ft  20ft minimum)
         *     - **Flying creatures:** Size matters less (can maneuver in 3D space)
         */
        get: operations["lookups.sizes.monsters"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/skills": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all D&D skills
         * @description Returns the 18 D&D 5e skills, each linked to one of the six ability scores.
         *     Skills represent trained abilities characters can become proficient in.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/skills                  # All 18 skills
         *     GET /api/v1/lookups/skills?q=stealth        # Search by name
         *     GET /api/v1/lookups/skills?ability=DEX      # Dexterity skills (Acrobatics, Sleight of Hand, Stealth)
         *     GET /api/v1/lookups/skills?ability=WIS      # Wisdom skills (Animal Handling, Insight, Medicine, Perception, Survival)
         *     GET /api/v1/lookups/skills?ability=CHA      # Charisma skills (Deception, Intimidation, Performance, Persuasion)
         *     ```
         *
         *     **Skills by Ability Score:**
         *     - **STR (1):** Athletics
         *     - **DEX (3):** Acrobatics, Sleight of Hand, Stealth
         *     - **INT (5):** Arcana, History, Investigation, Nature, Religion
         *     - **WIS (5):** Animal Handling, Insight, Medicine, Perception, Survival
         *     - **CHA (4):** Deception, Intimidation, Performance, Persuasion
         *     - **CON (0):** No skills (Constitution has no associated skills)
         *
         *     **Query Parameters:**
         *     - `q` (string): Search skills by name (partial match)
         *     - `ability` (string): Filter by ability score code (STR, DEX, CON, INT, WIS, CHA)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - **Character Building:** Find which skills use your highest ability score
         *     - **Party Composition:** Ensure skill coverage across the party (Perception, Investigation, Stealth)
         *     - **Class Selection:** Rogues excel at DEX skills, Clerics at WIS skills, Bards at CHA skills
         *     - **Background Selection:** Backgrounds grant 2 skill proficiencies - pick ones matching your build
         */
        get: operations["lookups.skills.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/skills/{skill}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single skill
         * @description Returns detailed information about a specific D&D skill including its associated
         *     ability score. Skills can be retrieved by ID, slug, or name.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/skills/1              # By ID
         *     GET /api/v1/lookups/skills/perception     # By slug
         *     GET /api/v1/lookups/skills/Perception     # By name
         *     ```
         *
         *     **Response includes:**
         *     - `id`, `name`, `slug`: Skill identification
         *     - `ability_score`: The governing ability (STR, DEX, CON, INT, WIS, CHA)
         */
        get: operations["lookups.skills.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/sources": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all D&D 5e sourcebooks
         * @description Returns a paginated list of official D&D 5th Edition sourcebooks (9 total).
         *     Includes core rulebooks, supplements, and adventure modules. Supports searching by name or code abbreviation.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/sources              # All sourcebooks
         *     GET /api/v1/lookups/sources?q=handbook   # Search for "Player's Handbook"
         *     GET /api/v1/lookups/sources?q=PHB        # Search by code abbreviation
         *     GET /api/v1/lookups/sources?per_page=20  # Custom page size
         *     ```
         *
         *     **D&D 5e Sourcebooks Reference:**
         *     - **Core Rulebooks (3):** Player's Handbook (PHB), Dungeon Master's Guide (DMG), Monster Manual (MM)
         *     - **Core Supplements (2):** Xanathar's Guide to Everything (XGE), Tasha's Cauldron of Everything (TCE)
         *     - **Rulebook Supplements (3):** Sword Coast Adventurer's Guide (SCAG), Volo's Guide to Monsters (VGM), Eberron: Rising From the Last War (ERLW)
         *     - **Adventures (1):** The Wild Beyond the Witchlight (TWBTW)
         *
         *     **Query Parameters:**
         *     - `q` (string): Search by sourcebook name or code (partial match, case-insensitive)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *     - `page` (int): Page number (default: 1)
         *
         *     **Use Cases:**
         *     - Building content filters: "Load all available sources for player to filter spells/items"
         *     - Source validation: "Check if a source code exists (e.g., is this 'XGE' official?)"
         *     - Content discovery: "Browse all available D&D rulebooks and supplements"
         *     - Publication reference: "What year was Xanathar's Guide published?"
         */
        get: operations["lookups.sources.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/sources/{source}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single sourcebook
         * @description Returns detailed information about a specific D&D 5e sourcebook including publication year,
         *     publisher, author, website, category, and full description.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/sources/PHB                 # Player's Handbook by code
         *     GET /api/v1/lookups/sources/1                   # By database ID
         *     ```
         *
         *     **Use Cases:**
         *     - Displaying source metadata: "Show the user details about where this spell originated"
         *     - Source credibility: "Verify official publication year and publisher"
         *     - Content attribution: "Link to the original source website and author information"
         */
        get: operations["lookups.sources.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/spells": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all spells
         * @description Returns a paginated list of 477 D&D 5e spells. Use `?filter=` for filtering and `?q=` for full-text search.
         *
         *     **Common Examples:**
         *     ```
         *     GET /api/v1/spells                                    # All spells
         *     GET /api/v1/spells?filter=level = 0                   # Cantrips (44 spells)
         *     GET /api/v1/spells?filter=level <= 3                  # Low-level spells
         *     GET /api/v1/spells?filter=school_code = EV            # Evocation spells
         *     GET /api/v1/spells?filter=class_slugs IN [bard]       # Bard spells (147 spells)
         *     GET /api/v1/spells?filter=concentration = true        # Concentration spells
         *     GET /api/v1/spells?q=fire                             # Full-text search for "fire"
         *     GET /api/v1/spells?q=fire&filter=level <= 3           # Search + filter combined
         *     ```
         *
         *     **Filterable Fields by Data Type:**
         *
         *     **Integer Fields** (Operators: `=`, `!=`, `>`, `>=`, `<`, `<=`, `TO`):
         *     - `id` (int): Spell ID
         *     - `level` (0-9): Spell level (0 = cantrip)
         *       - Examples: `level = 3`, `level >= 5`, `level 1 TO 5`
         *
         *     **String Fields** (Operators: `=`, `!=`):
         *     - `school_code` (string): Two-letter spell school code (EV, EN, AB, C, D, I, N, T)
         *       - Examples: `school_code = EV`, `school_code != EV`
         *     - `school_name` (string): Full spell school name (Evocation, Enchantment, etc.)
         *     - `casting_time`, `range`, `duration` (string): Descriptive text fields
         *
         *     **Boolean Fields** (Operators: `=`, `!=`, `IS NULL`, `EXISTS`):
         *     - `concentration` (bool): Requires concentration
         *       - Examples: `concentration = true`, `concentration = false`
         *     - `ritual` (bool): Can be cast as ritual
         *     - `requires_verbal` (bool): Requires verbal component (castable in Silence when false)
         *     - `requires_somatic` (bool): Requires somatic component (castable while grappled when false)
         *     - `requires_material` (bool): Requires material component
         *     - `material_consumed` (bool): Material component is consumed by the spell
         *       - Examples: `material_consumed = true`, `material_consumed = false`
         *       - Use case: Find reusable-focus vs consumed-component spells
         *
         *     **Computed Fields** (Issues #27, #28):
         *     - `material_cost_gp` (int): Gold piece cost of material components
         *       - Examples: `material_cost_gp >= 100`, `material_cost_gp EXISTS`
         *       - Use case: Find expensive spells, budget-friendly options
         *     - `aoe_type` (string): Area of effect shape (cone, sphere, cube, line, cylinder)
         *       - Examples: `aoe_type = sphere`, `aoe_type = cone`
         *       - Use case: Find AoE spells by shape
         *     - `aoe_size` (int): Primary dimension of area in feet
         *       - Examples: `aoe_size >= 20`, `aoe_size = 15`
         *       - Use case: Find large AoE spells
         *
         *     **Array Fields** (Operators: `IN`, `NOT IN`, `IS EMPTY`):
         *     - `class_slugs` (array): Class slugs that can learn this spell
         *       - Examples: `class_slugs IN [wizard, sorcerer]`, `class_slugs NOT IN [wizard]`
         *     - `tag_slugs` (array): Tag slugs (Note: Only 22% of spells have tags)
         *       - Examples: `tag_slugs IN [fire]`, `tag_slugs IS EMPTY`
         *     - `source_codes` (array): Source book codes (PHB, XGE, TCoE, etc.)
         *       - Examples: `source_codes IN [PHB, XGE]`, `source_codes NOT IN [UA]`
         *     - `damage_types` (array): Damage type codes (F=Fire, C=Cold, O=Force, etc.)
         *       - Examples: `damage_types IN [F]`, `damage_types IS EMPTY` (utility spells)
         *     - `saving_throws` (array): Ability codes (STR, DEX, CON, INT, WIS, CHA)
         *       - Examples: `saving_throws IN [DEX]`, `saving_throws IS EMPTY` (auto-hit spells)
         *     - `effect_types` (array): Effect type strings
         *
         *     **Complex Filter Examples:**
         *     - Range query: `?filter=level >= 3 AND level <= 5` OR `?filter=level 3 TO 5`
         *     - Multiple conditions: `?filter=class_slugs IN [wizard] AND level <= 3 AND concentration = true`
         *     - Array membership: `?filter=damage_types IN [F, C] AND level > 0`
         *     - Empty arrays: `?filter=damage_types IS EMPTY` (utility spells with no damage)
         *     - Subtle Spell candidates: `?filter=requires_verbal = false AND requires_somatic = false`
         *     - Expensive spells: `?filter=material_cost_gp >= 100`
         *     - Consumed materials: `?filter=material_consumed = true AND material_cost_gp >= 50`
         *     - Fireball-style spells: `?filter=aoe_type = sphere AND aoe_size >= 20`
         *     - All cone spells: `?filter=aoe_type = cone`
         *     - Large AoE spells: `?filter=aoe_size >= 30`
         *
         *     **Operator Reference:**
         *     See `docs/MEILISEARCH-FILTER-OPERATORS.md` for comprehensive operator documentation.
         *
         *     **Query Parameters:**
         *     - `q` (string): Full-text search (searches name, description)
         *     - `filter` (string): Meilisearch filter expression
         *     - `sort_by` (string): name, level, created_at, updated_at (default: name)
         *     - `sort_direction` (string): asc, desc (default: asc)
         *     - `per_page` (int): 1-100 (default: 15)
         *     - `page` (int): Page number (default: 1)
         */
        get: operations["spells.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/spells/{spell}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single spell
         * @description Returns detailed information about a specific spell including relationships
         *     like spell school, sources, damage effects, and associated classes.
         *     Supports selective relationship loading via the 'include' parameter.
         */
        get: operations["spells.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/spells/{spell}/classes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all classes that can learn this spell
         * @description Returns a list of D&D 5e character classes that have this spell in their spell list,
         *     ordered alphabetically by class name. This includes both base classes and subclasses
         *     that have access to the spell through their class spell lists.
         *
         *     **Examples:**
         *     - Wizard classes: `GET /api/v1/spells/fireball/classes`
         *     - Healing classes: `GET /api/v1/spells/cure-wounds/classes`
         *     - Cantrip classes: `GET /api/v1/spells/prestidigitation/classes`
         *
         *     **Use Cases:**
         *     - Character Building: "Can my Cleric learn this spell?"
         *     - Multiclass Planning: "Which classes get access to Counterspell?"
         *     - Spell Comparison: "Is this a Wizard-only spell or can multiple classes learn it?"
         *     - Class Analysis: "How many classes can cast healing spells?"
         *
         *     **Data Source:**
         *     Powered by the `class_spells` pivot table which tracks 1,917 class-spell relationships
         *     across 131 classes/subclasses and 477 spells imported from official D&D sourcebooks.
         */
        get: operations["spells.classes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/spells/{spell}/monsters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all monsters that can cast this spell
         * @description Returns a list of D&D 5e monsters that can cast this spell, ordered alphabetically
         *     by monster name. This includes spellcasting monsters like liches, archmages, dragons,
         *     and other creatures with innate spellcasting or prepared spells.
         *
         *     **Examples:**
         *     - Fireball casters: `GET /api/v1/spells/fireball/monsters` (11 monsters including Lich, Archmage)
         *     - Counterspell users: `GET /api/v1/spells/counterspell/monsters` (tactical spellcasters)
         *     - Teleport users: `GET /api/v1/spells/teleport/monsters` (mobile bosses)
         *
         *     **Use Cases:**
         *     - Encounter Building: "Which monsters can use this spell against my party?"
         *     - Boss Selection: "Find legendary spellcasters for high-level encounters"
         *     - Spell Tracking: "Does this enemy have access to teleportation?"
         *     - DM Reference: "Quick lookup of spell-using monsters for improvisation"
         *
         *     **Data Source:**
         *     Powered by the `entity_spells` polymorphic table which tracks 1,098 spell relationships
         *     across 129 spellcasting monsters. Synced automatically by SpellcasterStrategy during
         *     monster imports with 100% spell name match rate.
         */
        get: operations["spells.monsters"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/spells/{spell}/items": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all magic items that contain this spell
         * @description Returns a list of D&D 5e magic items that contain or can cast this spell, ordered
         *     alphabetically by item name. This includes spell scrolls, charged items (staves, wands,
         *     rods), and other magical equipment that grants access to spells.
         *
         *     **Examples:**
         *     - Fireball items: `GET /api/v1/spells/fireball/items` (Wand of Fireballs, Necklace of Fireballs)
         *     - Healing items: `GET /api/v1/spells/cure-wounds/items` (Spell Scrolls, healing staves)
         *     - Utility items: `GET /api/v1/spells/detect-magic/items` (wands, rods, scrolls)
         *
         *     **Use Cases:**
         *     - Treasure Generation: "What magic items grant access to this spell?"
         *     - Item Identification: "The party found a wand - what spells can it cast?"
         *     - Character Equipment: "Can I get this spell without multiclassing?"
         *     - Economy Balancing: "How many items in the game provide teleportation?"
         *
         *     **Data Source:**
         *     Powered by the `entity_spells` polymorphic table which tracks 107 spell relationships
         *     across charged items, spell scrolls, and magical equipment. Synced automatically by
         *     ChargedItemStrategy during item imports using case-insensitive spell name matching.
         */
        get: operations["spells.items"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/spells/{spell}/races": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all races that can cast this spell
         * @description Returns a list of D&D 5e races and subraces that can cast this spell through racial
         *     abilities, ordered alphabetically by race name. This includes innate spellcasting
         *     granted by racial traits like Drow Magic, High Elf Cantrip, or Tiefling spells.
         *
         *     **Examples:**
         *     - Dancing Lights: `GET /api/v1/spells/dancing-lights/races` (Drow innate cantrip)
         *     - Faerie Fire: `GET /api/v1/spells/faerie-fire/races` (Drow 3rd level racial spell)
         *     - Prestidigitation: `GET /api/v1/spells/prestidigitation/races` (High Elf cantrip choice)
         *
         *     **Use Cases:**
         *     - Character Creation: "Can I get this spell from my race?"
         *     - Build Optimization: "Which races grant access to utility cantrips?"
         *     - Race Comparison: "What innate spellcasting do different races provide?"
         *     - Campaign Balance: "How common are racial teleportation spells?"
         *
         *     **Data Source:**
         *     Powered by the `entity_spells` polymorphic table which tracks 21 spell relationships
         *     across races and subraces, representing innate racial spellcasting abilities from
         *     official D&D sourcebooks.
         */
        get: operations["spells.races"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/spell-schools": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all schools of magic
         * @description Returns the 8 schools of magic in D&D 5e. Every spell belongs to exactly one school,
         *     which defines its magical nature and affects class features like Wizard school specialization.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/spell-schools              # All 8 schools
         *     GET /api/v1/lookups/spell-schools?q=evocation  # Search by name
         *     ```
         *
         *     **The 8 Schools of Magic:**
         *     - **Abjuration (AB):** Protective magic - Shield, Counterspell, Dispel Magic
         *     - **Conjuration (C):** Summoning and teleportation - Misty Step, Conjure Animals
         *     - **Divination (D):** Information gathering - Detect Magic, Identify, Scrying
         *     - **Enchantment (EN):** Mind-affecting - Charm Person, Hold Person, Dominate
         *     - **Evocation (EV):** Damage and energy - Fireball, Lightning Bolt, Magic Missile
         *     - **Illusion (I):** Deception and trickery - Invisibility, Mirror Image, Major Image
         *     - **Necromancy (N):** Life and death - Animate Dead, Vampiric Touch, Raise Dead
         *     - **Transmutation (T):** Transformation - Polymorph, Haste, Enlarge/Reduce
         *
         *     **Query Parameters:**
         *     - `q` (string): Search schools by name (partial match)
         *     - `per_page` (int): Results per page, 1-100 (default: 50)
         *
         *     **Use Cases:**
         *     - **Wizard Specialization:** Choose a school to gain bonus features (Evocation for damage, Divination for utility)
         *     - **Spell Selection:** Browse spells by school to build a thematic caster
         *     - **Counterspell Decisions:** Identify spell schools to prioritize countering
         */
        get: operations["lookups.spell-schools.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/spell-schools/{spellSchool}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single school of magic
         * @description Returns detailed information about a specific school of magic.
         *     Schools can be retrieved by ID, code, slug, or name.
         *
         *     **Examples:**
         *     ```
         *     GET /api/v1/lookups/spell-schools/3           # By ID
         *     GET /api/v1/lookups/spell-schools/EV          # By code
         *     GET /api/v1/lookups/spell-schools/evocation   # By slug
         *     GET /api/v1/lookups/spell-schools/Evocation   # By name
         *     ```
         *
         *     **Response includes:**
         *     - `id`, `code`, `name`, `slug`: School identification
         *     - `description`: What this school of magic represents
         *
         *     **Related endpoint:** Use `/api/v1/lookups/spell-schools/{id}/spells` to list all spells in this school.
         */
        get: operations["lookups.spell-schools.show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/spell-schools/{spellSchool}/spells": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all spells in this school of magic
         * @description Returns a paginated list of spells belonging to a specific school of magic.
         *     Supports all spell fields including level, concentration, ritual, damage types,
         *     saving throws, and component requirements.
         *
         *     **Basic Examples:**
         *     - Evocation spells: `GET /api/v1/spell-schools/evocation/spells`
         *     - Evocation by ID: `GET /api/v1/spell-schools/3/spells`
         *     - Evocation by code: `GET /api/v1/spell-schools/EV/spells`
         *     - Pagination: `GET /api/v1/spell-schools/evocation/spells?per_page=25&page=2`
         *
         *     **School-Specific Use Cases:**
         *     - Damage dealers (Evocation): Direct damage spells (Fireball, Magic Missile, Lightning Bolt)
         *     - Mind control (Enchantment): Charm Person, Dominate Monster, Suggestion
         *     - Buffs & debuffs (Transmutation): Haste, Slow, Polymorph, Enlarge/Reduce
         *     - Information gathering (Divination): Detect Magic, Scrying, Identify
         *     - Defense (Abjuration): Shield, Counterspell, Dispel Magic, Protection spells
         *     - Summoning (Conjuration): Summon spells, Create Food and Water, Teleport
         *     - Trickery (Illusion): Invisibility, Mirror Image, Silent Image, Disguise Self
         *     - Undead & life force (Necromancy): Animate Dead, Vampiric Touch, Speak with Dead
         *
         *     **Character Building:**
         *     - Wizard school specialization (pick one school to focus on)
         *     - Spell selection optimization (identify your school's best spells)
         *     - Thematic spellcasting (pure Evocation blaster, pure Enchantment controller)
         *
         *     **Reference Data:**
         *     - 8 schools of magic in D&D 5e
         *     - Total: 477 spells across all schools
         *     - Evocation: ~60 spells (largest school, damage-focused)
         *     - Enchantment: ~40 spells (mind-affecting)
         *     - Transmutation: ~55 spells (versatile utility)
         *     - Conjuration: ~45 spells (summoning & teleportation)
         */
        get: operations["lookups.spell-schools.spells"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/lookups/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all tags
         * @description Returns all tags used to categorize D&D 5e entities across the system. Tags enable semantic
         *     organization of spells, monsters, items, races, classes, feats, and backgrounds. Use the
         *     optional `type` parameter to filter tags by entity type for focused frontend dropdowns.
         *
         *     **Tag System Overview:**
         *     Tags are polymorphic labels applied to entities for semantic categorization. Each tag has:
         *     - **id** (int): Unique tag identifier
         *     - **name** (string): Human-readable display name (e.g., "Ritual", "Concentration")
         *     - **slug** (string): URL-friendly identifier (e.g., "ritual", "concentration")
         *     - **type** (string): Entity category the tag belongs to (spell, monster, item, race, class, feat, background)
         *
         *     **Common Examples:**
         *     ```
         *     GET /api/v1/lookups/tags                    # All tags across all entity types
         *     GET /api/v1/lookups/tags?type=spell         # Spell-specific tags (e.g., "Ritual", "Concentration")
         *     GET /api/v1/lookups/tags?type=monster       # Monster-specific tags (e.g., "Legendary", "Fiend")
         *     GET /api/v1/lookups/tags?type=item          # Item-specific tags (e.g., "Magic", "Artifact")
         *     ```
         *
         *     **Spell Tag Examples:**
         *     - "Ritual" - Can be cast as a ritual without using spell slot
         *     - "Concentration" - Requires concentration to maintain the spell
         *     - "Healing" - Provides restoration or damage recovery
         *     - "Control" - Manipulates enemy movement or positioning
         *
         *     **Monster Tag Examples:**
         *     - "Legendary" - Has legendary actions
         *     - "Lair Actions" - Has lair-based abilities
         *     - "Fiend" - Creature type classification
         *
         *     **Item Tag Examples:**
         *     - "Artifact" - Legendary item of great power
         *     - "Magical" - Enchanted or magical item
         *     - "Cursed" - Has curse mechanics
         *     - "Wondrous" - Miscellaneous magical item
         *
         *     **Query Parameters:**
         *     - `type` (string): Filter tags by entity type (spell, monster, item, race, class, feat, background)
         *
         *     **Use Cases:**
         *     - **Frontend Dropdowns:** Populate multi-select filters in spell/item/monster browsers
         *     - **Entity Discovery:** "Show me all ritual spells" or "legendary monsters"
         *     - **Character Building:** Filter spells by "Concentration" to plan action economy
         *     - **Encounter Design:** Find monsters tagged as "Legendary" or "Fiend" for boss encounters
         *     - **Loot Tables:** Browse items tagged as "Artifact" or "Magical" for treasure rewards
         *
         *     **Data Source:**
         *     Tag system powered by Spatie Laravel Tags package. All tags are synced during entity imports
         *     and tagged dynamically through the application. Total unique tags: 100+
         */
        get: operations["lookups.tags.index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AbilityScoreMethod
         * @enum {string}
         */
        AbilityScoreMethod: "manual" | "point_buy" | "standard_array";
        /** AbilityScoreResource */
        AbilityScoreResource: {
            id: number;
            code: string;
            name: string;
        };
        /** AreaOfEffectResource */
        AreaOfEffectResource: {
            type: string;
            size: number;
            width?: number;
            height?: number;
        };
        /** BackgroundResource */
        BackgroundResource: {
            id: number;
            slug: string;
            name: string;
            /** @description Feature extraction (computed from traits with category='feature') */
            feature_name: string;
            feature_description: string;
            /** @description Relationships */
            traits?: components["schemas"]["TraitResource"][];
            proficiencies?: components["schemas"]["ProficiencyResource"][];
            sources?: components["schemas"]["EntitySourceResource"][];
            languages?: components["schemas"]["EntityLanguageResource"][];
            equipment?: components["schemas"]["EntityItemResource"][];
            tags?: components["schemas"]["TagResource"][];
            /**
             * @description Convenience field: flattened data tables from all traits
             *     Includes Personality Traits, Ideals, Bonds, Flaws roll tables
             */
            data_tables?: unknown[] | null;
        };
        /** CharacterClassResource */
        CharacterClassResource: {
            id: number;
            name: string;
            slug: string;
        };
        /** CharacterEquipmentResource */
        CharacterEquipmentResource: {
            id: number;
            item: {
                id: number;
                name: string;
                slug: string;
                item_type: string;
                armor_class: number | null;
                damage_dice: string | null;
                weight: string | null;
            };
            quantity: number;
            equipped: boolean;
            location: string;
            proficiency_status?: {
                [key: string]: unknown;
            };
        };
        /** CharacterResource */
        CharacterResource: {
            id: number;
            name: string;
            level: number | 1;
            experience_points: number | 0;
            /** @description Completion status */
            is_complete: string;
            validation_status: string;
            /** @description Ability score method */
            ability_score_method: string;
            /** @description Ability scores (as STR/DEX/CON/INT/WIS/CHA keyed array) */
            ability_scores: {
                STR: number | null;
                DEX: number | null;
                CON: number | null;
                INT: number | null;
                WIS: number | null;
                CHA: number | null;
            };
            modifiers: unknown[];
            /** @description Calculated stats */
            proficiency_bonus: number;
            /** @description Combat stats (nullable until calculated) */
            max_hit_points: number | null;
            current_hit_points: number | null;
            temp_hit_points: number;
            armor_class: string;
            /** @description Level-up tracking */
            asi_choices_remaining: number | 0;
            /** @description Equipped items summary */
            equipped: {
                armor: {
                    id: string;
                    name: string;
                    armor_class: string;
                };
                shield: {
                    id: string;
                    name: string;
                    armor_class: string;
                };
            };
            /** @description Proficiency penalties from equipped items */
            proficiency_penalties: {
                has_armor_penalty: boolean;
                has_weapon_penalty: boolean;
                penalties: unknown[];
            };
            /** @description Relationships (conditionally loaded) */
            race?: {
                id: number;
                name: string;
                slug: string;
            } | null;
            class?: {
                id: number;
                name: string;
                slug: string;
            } | null;
            background?: {
                id: number;
                name: string;
                slug: string;
            } | null;
            /** @description Timestamps */
            created_at: string;
            updated_at: string;
        };
        /** CharacterSpellResource */
        CharacterSpellResource: {
            id: number;
            spell: {
                id: number;
                name: string;
                slug: string;
                level: number;
                school: string;
                casting_time: string;
                range: string;
                components: string;
                duration: string;
                concentration: boolean;
                ritual: boolean;
            };
            preparation_status: string;
            source: string;
            level_acquired: number | null;
            is_prepared: boolean;
            is_always_prepared: boolean;
        };
        /** CharacterStatsResource */
        CharacterStatsResource: {
            character_id: number;
            level: number;
            proficiency_bonus: number;
            ability_scores: unknown[];
            saving_throws: unknown[];
            armor_class: number | null;
            hit_points: {
                max: number | null;
                current: number | null;
                temporary: number;
            };
            spellcasting: unknown[] | null;
            spell_slots: unknown[];
            preparation_limit: number | null;
            prepared_spell_count: number;
        };
        /** CharacterStoreRequest */
        CharacterStoreRequest: {
            name: string;
            /** @description Core choices (nullable for wizard-style creation) */
            race_id?: number | null;
            class_id?: number | null;
            background_id?: number | null;
            /** @description Ability scores (manual entry, range 3-20) */
            strength?: number | null;
            dexterity?: number | null;
            constitution?: number | null;
            intelligence?: number | null;
            wisdom?: number | null;
            charisma?: number | null;
            /** @description Level (default 1) */
            level?: number;
        };
        /** CharacterUpdateRequest */
        CharacterUpdateRequest: {
            name?: string;
            /** @description Core choices */
            race_id?: number | null;
            class_id?: number | null;
            background_id?: number | null;
            /** @description Ability score method */
            ability_score_method?: components["schemas"]["AbilityScoreMethod"];
            strength?: number | null;
            dexterity?: number | null;
            constitution?: number | null;
            intelligence?: number | null;
            wisdom?: number | null;
            charisma?: number | null;
            /** @description Level */
            level?: number;
            /** @description Experience points */
            experience_points?: number;
            /** @description Hit points */
            max_hit_points?: number | null;
            current_hit_points?: number | null;
            temp_hit_points?: number;
            /** @description Armor class */
            armor_class?: number | null;
        };
        /** ClassComputedResource */
        ClassComputedResource: {
            /** @description Pre-computed hit points using D&D 5e formulas. */
            hit_points?: components["schemas"]["HitPointsResource"];
            /** @description Spell slot summary for frontend column visibility optimization. */
            spell_slot_summary?: components["schemas"]["SpellSlotSummaryResource"];
            /** @description Section counts for lazy-loading accordions in UI. */
            section_counts?: components["schemas"]["SectionCountsResource"];
            /** @description Pre-computed progression table for detail views. */
            progression_table?: components["schemas"]["ProgressionTableResource"];
        };
        /** ClassFeatureResource */
        ClassFeatureResource: {
            id: number;
            level: number;
            feature_name: string;
            description: string;
            is_optional: boolean;
            is_multiclass_only: boolean;
            is_choice_option: string;
            is_always_prepared: string;
            parent_feature_id: number | null;
            sort_order: number;
            /** @description Relationships */
            data_tables?: components["schemas"]["EntityDataTableResource"][];
            /** @description Subclass spells (domain, circle, expanded) */
            spells?: {
                spell: components["schemas"]["SpellResource"];
                level_requirement: string;
                is_cantrip: string;
            }[];
            /** @description Nested child features (choice options) */
            choice_options?: components["schemas"]["ClassFeatureResource"][];
        };
        /** ClassLevelProgressionResource */
        ClassLevelProgressionResource: {
            id: number;
            level: number;
            cantrips_known: number | null;
            spells_known: number | null;
            spell_slots_1st: number | null;
            spell_slots_2nd: number | null;
            spell_slots_3rd: number | null;
            spell_slots_4th: number | null;
            spell_slots_5th: number | null;
            spell_slots_6th: number | null;
            spell_slots_7th: number | null;
            spell_slots_8th: number | null;
            spell_slots_9th: number | null;
        };
        /** ClassResource */
        ClassResource: {
            /**
             * @description === BASE FIELDS ===
             *     Note: hit_die and spellcasting_ability use effective values that
             *     inherit from parent class for subclasses (see class docblock)
             */
            id: string;
            slug: string;
            name: string;
            hit_die: string;
            description: string;
            archetype: string;
            primary_ability: string;
            spellcasting_ability?: components["schemas"]["AbilityScoreResource"];
            parent_class_id: string;
            is_base_class: string;
            subclass_level: string;
            spellcasting_type: string;
            /** @description === MULTICLASS REQUIREMENTS === */
            multiclass_requirements?: {
                type: string;
                requirements: unknown[];
            };
            /** @description === RELATIONSHIPS === */
            parent_class?: components["schemas"]["ClassResource"];
            subclasses?: components["schemas"]["ClassResource"][];
            proficiencies?: components["schemas"]["ProficiencyResource"][];
            traits?: components["schemas"]["TraitResource"][];
            /** @description Features: Use getAllFeatures() to merge base + subclass features when appropriate */
            features?: components["schemas"]["ClassFeatureResource"][];
            level_progression?: components["schemas"]["ClassLevelProgressionResource"][];
            counters?: components["schemas"]["GroupedCounterResource"][];
            spells?: components["schemas"]["SpellResource"][];
            optional_features?: components["schemas"]["OptionalFeatureResource"][];
            equipment?: components["schemas"]["EntityItemResource"][];
            sources?: components["schemas"]["EntitySourceResource"][];
            tags?: components["schemas"]["TagResource"][];
            /**
             * @description Pre-resolved inheritance data from parent class.
             *     Only present for subclasses - contains data they inherit from their base class.
             *     Note: hit_points is NOT included here - use computed.hit_points instead (resolves inheritance automatically).
             */
            inherited_data?: {
                hit_die: number | null;
                spellcasting_ability: {
                    id: number;
                    code: string;
                    name: string;
                } | null;
                counters: components["schemas"]["GroupedCounterResource"][] | null;
                traits: components["schemas"]["TraitResource"][] | null;
                level_progression: components["schemas"]["ClassLevelProgressionResource"][] | null;
                equipment: components["schemas"]["EntityItemResource"][] | null;
                proficiencies: components["schemas"]["ProficiencyResource"][] | null;
                spell_slot_summary: {
                    has_spell_slots: boolean;
                    max_spell_level: number | null;
                    available_levels: number[];
                    has_cantrips: boolean;
                    caster_type: string | null;
                } | null;
            } | null;
            computed?: components["schemas"]["ClassComputedResource"] | null;
        };
        /** ConditionResource */
        ConditionResource: {
            id: number;
            name: string;
            slug: string;
            description: string;
        };
        /** CounterProgressionResource */
        CounterProgressionResource: {
            /** @description Character level (1-20) */
            level: number;
            /** @description Counter value at this level, or "Unlimited" for infinite uses */
            value: number | string;
        };
        /** DamageTypeResource */
        DamageTypeResource: {
            id: number;
            code: string;
            name: string;
        };
        /** EntityConditionResource */
        EntityConditionResource: {
            id: number;
            condition_id: number | null;
            condition?: components["schemas"]["ConditionResource"];
            effect_type: string;
            description: string | null;
        };
        /** EntityDataTableEntryResource */
        EntityDataTableEntryResource: {
            id: number;
            roll_min: number | null;
            roll_max: number | null;
            result_text: string | null;
            level: number | null;
            sort_order: number;
            resource_cost?: number | null;
        };
        /** EntityDataTableResource */
        EntityDataTableResource: {
            id: number;
            table_name: string;
            dice_type: string | null;
            table_type: string;
            description: string | null;
            entries?: components["schemas"]["EntityDataTableEntryResource"][];
        };
        /** EntityItemResource */
        EntityItemResource: {
            id: number;
            item_id: number | null;
            item?: components["schemas"]["ItemResource"];
            quantity: number;
            is_choice: boolean;
            choice_group: string | null;
            choice_option: number | null;
            choice_description: string | null;
            proficiency_subcategory: string | null;
            description: string | null;
        };
        /** EntityLanguageResource */
        EntityLanguageResource: {
            language?: components["schemas"]["LanguageResource"];
            is_choice: boolean;
            quantity?: number;
        };
        /** EntityPrerequisiteResource */
        EntityPrerequisiteResource: {
            id: number;
            prerequisite_type: string | null;
            prerequisite_id: number | null;
            minimum_value: number | null;
            description: string | null;
            group_id: number;
            /**
             * @description Type-specific nested resources (only one will be present based on prerequisite_type)
             *     Note: Removed generic 'prerequisite' field to avoid duplicate data (Issue #73)
             */
            ability_score?: components["schemas"]["AbilityScoreResource"];
            race?: components["schemas"]["RaceResource"];
            skill?: components["schemas"]["SkillResource"];
            proficiency_type?: components["schemas"]["ProficiencyTypeResource"];
        };
        /** EntitySenseResource */
        EntitySenseResource: {
            type: string;
            name: string;
            range: number;
            is_limited: boolean;
            notes: string | null;
        };
        /** EntitySourceResource */
        EntitySourceResource: {
            code: string;
            name: string;
            pages: string | null;
        };
        /** EntitySpellResource */
        EntitySpellResource: {
            id: number;
            spell_id: number | null;
            spell?: components["schemas"]["SpellResource"];
            ability_score_id: number | null;
            ability_score?: components["schemas"]["AbilityScoreResource"];
            level_requirement: number | null;
            usage_limit: string | null;
            is_cantrip: boolean;
            /** @description Charge costs (for items that cast spells) */
            charges_cost_min: number | null;
            charges_cost_max: number | null;
            charges_cost_formula: string | null;
            /** @description Choice support */
            is_choice: boolean;
            choice_count?: number | null;
            choice_group?: string | null;
            max_level?: number | null;
            school?: components["schemas"]["SpellSchoolResource"];
            character_class?: components["schemas"]["CharacterClassResource"];
            is_ritual_only?: boolean;
        };
        /** FeatResource */
        FeatResource: {
            id: number;
            slug: string;
            name: string;
            prerequisites_text: string | null;
            prerequisites?: components["schemas"]["EntityPrerequisiteResource"][];
            description: string;
            /** @description Computed fields */
            is_half_feat: string;
            parent_feat_slug: string;
            /** @description Relationships */
            modifiers?: components["schemas"]["ModifierResource"][];
            proficiencies?: components["schemas"]["ProficiencyResource"][];
            conditions?: components["schemas"]["EntityConditionResource"][];
            sources?: components["schemas"]["EntitySourceResource"][];
            tags?: components["schemas"]["TagResource"][];
            /** @description Use entitySpellRecords for EntitySpell pivot records (includes spell choices) */
            spells?: components["schemas"]["EntitySpellResource"][];
            spell_choices?: components["schemas"]["SpellChoiceResource"][] | null;
        };
        /** GroupedCounterResource */
        GroupedCounterResource: {
            name: string;
            /** @enum {string} */
            reset_timing: "Short Rest" | "Long Rest" | "Does Not Reset";
            progression: components["schemas"]["CounterProgressionResource"][];
        };
        /** HitPointsResource */
        HitPointsResource: {
            hit_die: string;
            hit_die_numeric: number;
            first_level: {
                value: number;
                description: string;
            };
            higher_levels: {
                roll: string;
                average: number;
                description: string;
            };
        };
        /** ItemAbilityResource */
        ItemAbilityResource: {
            id: number;
            item_id: number;
            ability_type: string;
            spell_id: number | null;
            name: string | null;
            description: string | null;
            roll_formula: string | null;
            charges_cost: number | null;
            usage_limit: string | null;
            save_dc: number | null;
            attack_bonus: number | null;
            sort_order: number;
            /** @description Relationships */
            spell?: components["schemas"]["SpellResource"];
        };
        /** ItemPropertyResource */
        ItemPropertyResource: {
            id: number;
            code: string;
            name: string;
            description: string;
        };
        /** ItemResource */
        ItemResource: {
            id: number;
            name: string;
            slug: string;
            item_type_id: number;
            detail: string | null;
            rarity: string | null;
            requires_attunement: boolean;
            is_magic: boolean;
            cost_cp: number | null;
            weight: string | null;
            damage_dice: string | null;
            versatile_damage: string | null;
            damage_type_id: number | null;
            range_normal: number | null;
            range_long: number | null;
            armor_class: number | null;
            strength_requirement: number | null;
            stealth_disadvantage: boolean;
            description: string;
            /** @description Charge mechanics (magic items) */
            charges_max: string | null;
            recharge_formula: string | null;
            recharge_timing: string | null;
            /** @description Computed fields */
            proficiency_category: string;
            magic_bonus: string;
            /** @description Relationships */
            item_type?: components["schemas"]["ItemTypeResource"];
            damage_type?: components["schemas"]["DamageTypeResource"];
            properties?: components["schemas"]["ItemPropertyResource"][];
            abilities?: components["schemas"]["ItemAbilityResource"][];
            data_tables?: components["schemas"]["EntityDataTableResource"][];
            sources?: components["schemas"]["EntitySourceResource"][];
            proficiencies?: components["schemas"]["ProficiencyResource"][];
            modifiers?: components["schemas"]["ModifierResource"][];
            prerequisites?: components["schemas"]["EntityPrerequisiteResource"][];
            tags?: components["schemas"]["TagResource"][];
            spells?: components["schemas"]["ItemSpellResource"][];
            saving_throws?: components["schemas"]["SavingThrowResource"][];
        };
        /** ItemSpellResource */
        ItemSpellResource: {
            id: string;
            name: string;
            slug: string;
            level: string;
            school?: components["schemas"]["SpellSchoolResource"];
            /** @description Charge cost data from pivot table (entity_spells) */
            charges_cost_min: string;
            charges_cost_max: string;
            charges_cost_formula: string;
            /** @description Other usage metadata from pivot */
            usage_limit: string;
            level_requirement: string;
        };
        /** ItemTypeResource */
        ItemTypeResource: {
            id: number;
            code: string;
            name: string;
            description: string | null;
        };
        /** LanguageResource */
        LanguageResource: {
            id: number;
            name: string;
            slug: string;
            script: string | null;
            typical_speakers: string | null;
            description: string | null;
        };
        /** LoginRequest */
        LoginRequest: {
            /** Format: email */
            email: string;
            password: string;
        };
        /** ModifierResource */
        ModifierResource: {
            id: number;
            modifier_category: string;
            ability_score?: components["schemas"]["AbilityScoreResource"];
            skill?: components["schemas"]["SkillResource"];
            damage_type?: components["schemas"]["DamageTypeResource"] | null;
            value: string;
            condition: string | null;
            is_choice: boolean;
            choice_count: number | null;
            choice_constraint: string | null;
            level: number | null;
        };
        /** MonsterActionResource */
        MonsterActionResource: {
            id: number;
            action_type: string;
            name: string;
            description: string;
            attack_data: string | null;
            recharge: string | null;
            sort_order: number;
        };
        /** MonsterLegendaryActionResource */
        MonsterLegendaryActionResource: {
            id: number;
            name: string;
            description: string;
            action_cost: number;
            is_lair_action: boolean;
            attack_data: string | null;
            recharge: string | null;
            sort_order: number;
        };
        /** MonsterResource */
        MonsterResource: {
            id: number;
            slug: string;
            name: string;
            sort_name: string | null;
            size?: components["schemas"]["SizeResource"];
            type: string;
            alignment: string | null;
            is_npc: boolean;
            armor_class: number;
            armor_type: string | null;
            hit_points_average: number;
            hit_dice: string;
            speed_walk: number;
            speed_fly: number | null;
            speed_swim: number | null;
            speed_burrow: number | null;
            speed_climb: number | null;
            can_hover: boolean;
            strength: number;
            dexterity: number;
            constitution: number;
            intelligence: number;
            wisdom: number;
            charisma: number;
            challenge_rating: string;
            experience_points: number;
            proficiency_bonus: string;
            is_legendary: string;
            passive_perception: number | null;
            languages: string | null;
            senses?: components["schemas"]["EntitySenseResource"][];
            description: string | null;
            traits?: components["schemas"]["MonsterTraitResource"][];
            actions?: components["schemas"]["MonsterActionResource"][];
            reactions?: components["schemas"]["MonsterActionResource"][];
            legendary_actions?: components["schemas"]["MonsterLegendaryActionResource"][];
            lair_actions?: components["schemas"]["MonsterLegendaryActionResource"][];
            spells?: components["schemas"]["MonsterSpellResource"][];
            modifiers?: components["schemas"]["ModifierResource"][];
            conditions?: components["schemas"]["EntityConditionResource"][];
            sources?: components["schemas"]["EntitySourceResource"][];
            tags?: components["schemas"]["TagResource"][];
        };
        /** MonsterSpellResource */
        MonsterSpellResource: {
            id: string;
            name: string;
            slug: string;
            level: string;
            school?: components["schemas"]["SpellSchoolResource"];
            /** @description Usage metadata from pivot table (entity_spells) */
            usage_limit: string;
            level_requirement: string;
            is_cantrip: string;
        };
        /** MonsterTraitResource */
        MonsterTraitResource: {
            id: number;
            name: string;
            description: string;
            attack_data: string | null;
            sort_order: number;
        };
        /** OptionalFeatureResource */
        OptionalFeatureResource: {
            id: number;
            slug: string;
            name: string;
            feature_type: string;
            feature_type_label: string;
            level_requirement: number | null;
            prerequisite_text: string | null;
            description: string;
            /** @description Spell-like properties */
            casting_time: string | null;
            range: string | null;
            duration: string | null;
            spell_school?: components["schemas"]["SpellSchoolResource"];
            /** @description Resource properties */
            resource_type: string;
            resource_cost: number | null;
            /** @description Computed attribute */
            has_spell_mechanics: string;
            /** @description Relationships */
            classes?: components["schemas"]["ClassResource"][];
            sources?: components["schemas"]["EntitySourceResource"][];
            tags?: components["schemas"]["TagResource"][];
        };
        /** ProficiencyResource */
        ProficiencyResource: {
            id: number;
            proficiency_type: string;
            proficiency_subcategory: string | null;
            proficiency_type_id: number | null;
            proficiency_type_detail?: components["schemas"]["ProficiencyTypeResource"];
            skill?: components["schemas"]["SkillResource"];
            /** @description Linked item reference (for weapon/armor proficiencies). */
            item?: {
                id: number;
                name: string;
            } | null;
            ability_score?: components["schemas"]["AbilityScoreResource"];
            proficiency_name: string | null;
            grants: boolean;
            is_choice: boolean;
            choice_group: string | null;
            choice_option: number | null;
            quantity: number | null;
            level: number | null;
        };
        /** ProficiencyTypeResource */
        ProficiencyTypeResource: {
            id: number;
            slug: string;
            name: string;
            category: string;
            subcategory: string | null;
            item?: components["schemas"]["ItemResource"];
        };
        /** ProgressionColumnResource */
        ProgressionColumnResource: {
            key: string;
            label: string;
            type: string;
        };
        /** ProgressionRowResource */
        ProgressionRowResource: {
            level: number;
            proficiency_bonus: string;
            features: string;
            sneak_attack?: string;
            ki_points?: number;
            martial_arts?: string;
            rage_damage?: string;
            rages?: number;
            cantrips_known?: number;
            spell_slots_1st?: number;
            spell_slots_2nd?: number;
            spell_slots_3rd?: number;
            spell_slots_4th?: number;
            spell_slots_5th?: number;
            spell_slots_6th?: number;
            spell_slots_7th?: number;
            spell_slots_8th?: number;
            spell_slots_9th?: number;
        };
        /** ProgressionTableResource */
        ProgressionTableResource: {
            columns: components["schemas"]["ProgressionColumnResource"][];
            rows: components["schemas"]["ProgressionRowResource"][];
        };
        /** RaceResource */
        RaceResource: {
            id: number;
            slug: string;
            name: string;
            size?: components["schemas"]["SizeResource"];
            speed: number;
            fly_speed: number | null;
            swim_speed: number | null;
            climb_speed: number | null;
            is_subrace: string;
            traits?: components["schemas"]["TraitResource"][];
            modifiers?: components["schemas"]["ModifierResource"][];
            sources?: components["schemas"]["EntitySourceResource"][];
            parent_race?: components["schemas"]["RaceResource"];
            subraces?: components["schemas"]["RaceResource"][];
            proficiencies?: components["schemas"]["ProficiencyResource"][];
            languages?: components["schemas"]["EntityLanguageResource"][];
            conditions?: components["schemas"]["EntityConditionResource"][];
            /** @description Use entitySpellRecords for EntitySpell pivot records (includes pivot data like level_requirement) */
            spells?: components["schemas"]["EntitySpellResource"][];
            senses?: components["schemas"]["EntitySenseResource"][];
            tags?: components["schemas"]["TagResource"][];
            /**
             * @description Data inherited from parent race. Only included for subraces when parent is loaded.
             *     Contains the base race's traits, modifiers, proficiencies, languages, conditions, and senses.
             */
            inherited_data?: {
                traits: components["schemas"]["TraitResource"][] | null;
                modifiers: components["schemas"]["ModifierResource"][] | null;
                proficiencies: components["schemas"]["ProficiencyResource"][] | null;
                languages: components["schemas"]["EntityLanguageResource"][] | null;
                conditions: components["schemas"]["EntityConditionResource"][] | null;
                senses: components["schemas"]["EntitySenseResource"][] | null;
            } | null;
        };
        /** RegisterRequest */
        RegisterRequest: {
            name: string;
            /** Format: email */
            email: string;
            password: string;
            password_confirmation: string;
        };
        /** SavingThrowResource */
        SavingThrowResource: {
            /** @description The ability score for this saving throw. */
            ability_score: {
                id: number;
                code: string;
                name: string;
            };
            dc: string;
            save_effect: string;
            is_initial_save: boolean;
            /** @description 'advantage', 'disadvantage', or null */
            save_modifier: string | null;
        };
        /** SearchResource */
        SearchResource: {
            /** @description Search results grouped by entity type. */
            data: {
                spells: components["schemas"]["SpellResource"][];
                items: components["schemas"]["ItemResource"][];
                races: components["schemas"]["RaceResource"][];
                classes: components["schemas"]["ClassResource"][];
                backgrounds: components["schemas"]["BackgroundResource"][];
                feats: components["schemas"]["FeatResource"][];
                monsters: components["schemas"]["MonsterResource"][];
            };
            /** @description Search metadata. */
            meta: {
                query: string;
                types_searched: string[];
                limit_per_type: number;
                total_results: number;
            };
        };
        /** SectionCountsResource */
        SectionCountsResource: {
            features: string;
            multiclass_features: string;
            proficiencies: string;
            traits: string;
            subclasses: string;
            spells: string;
            counters: string;
            optional_features: string;
        };
        /** SizeResource */
        SizeResource: {
            id: number;
            code: string;
            name: string;
        };
        /** SkillResource */
        SkillResource: {
            id: number;
            name: string;
            slug: string;
            ability_score?: components["schemas"]["AbilityScoreResource"];
        };
        /** SourceResource */
        SourceResource: {
            id: number;
            code: string;
            name: string;
            publisher: string;
            publication_year: number | null;
            url: string | null;
            author: string | null;
            artist: string | null;
            website: string | null;
            category: string | null;
            description: string | null;
        };
        /** SpellChoiceResource */
        SpellChoiceResource: {
            choice_group: string;
            choice_count: number;
            max_level: number;
            is_ritual_only: boolean;
            allowed_schools: components["schemas"]["SpellSchoolResource"][];
            allowed_class: components["schemas"]["CharacterClassResource"] | null;
        };
        /** SpellEffectResource */
        SpellEffectResource: {
            id: number;
            effect_type: string;
            description: string | null;
            dice_formula: string | null;
            base_value: number | null;
            scaling_type: string | null;
            min_character_level: number | null;
            min_spell_slot: number | null;
            scaling_increment: string | null;
            projectile_count: number | null;
            projectile_per_level: number | null;
            projectile_name: string | null;
            damage_type?: components["schemas"]["DamageTypeResource"];
        };
        /** SpellResource */
        SpellResource: {
            id: number;
            slug: string;
            name: string;
            level: number;
            school?: components["schemas"]["SpellSchoolResource"];
            casting_time: string;
            casting_time_type: string;
            range: string;
            components: string;
            material_components: string | null;
            material_cost_gp: string;
            material_consumed: string;
            duration: string;
            needs_concentration: boolean;
            is_ritual: boolean;
            description: string;
            higher_levels: string | null;
            /** @description Component breakdown (computed from components string) */
            requires_verbal: boolean;
            requires_somatic: boolean;
            requires_material: boolean;
            /** @description Area of effect (parsed from description) */
            area_of_effect?: components["schemas"]["AreaOfEffectResource"];
            sources?: components["schemas"]["EntitySourceResource"][];
            effects?: components["schemas"]["SpellEffectResource"][];
            classes?: components["schemas"]["ClassResource"][];
            tags?: components["schemas"]["TagResource"][];
            saving_throws?: components["schemas"]["SavingThrowResource"][];
            data_tables?: components["schemas"]["EntityDataTableResource"][];
        };
        /** SpellSchoolResource */
        SpellSchoolResource: {
            id: number;
            code: string;
            name: string;
            description: string | null;
        };
        /** SpellSlotSummaryResource */
        SpellSlotSummaryResource: {
            has_spell_slots: boolean;
            max_spell_level: string;
            available_levels: string;
            has_cantrips: boolean;
            caster_type: string;
        };
        /** StoreEquipmentRequest */
        StoreEquipmentRequest: {
            item_id: number;
            quantity?: number | null;
        };
        /** TagResource */
        TagResource: {
            id: string;
            name: string;
            slug: string;
            type: string;
        };
        /** TraitResource */
        TraitResource: {
            id: string;
            name: string;
            category: string;
            description: string;
            sort_order: string;
            data_tables?: components["schemas"]["EntityDataTableResource"][];
        };
        /** UpdateEquipmentRequest */
        UpdateEquipmentRequest: {
            equipped?: boolean | null;
            quantity?: number | null;
        };
    };
    responses: {
        /** @description Validation error */
        ValidationException: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @description Errors overview. */
                    message: string;
                    /** @description A detailed description of each field that failed validation. */
                    errors: {
                        [key: string]: string[];
                    };
                };
            };
        };
        /** @description Unauthenticated */
        AuthenticationException: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @description Error overview. */
                    message: string;
                };
            };
        };
        /** @description Not found */
        ModelNotFoundException: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @description Error overview. */
                    message: string;
                };
            };
        };
    };
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    "lookups.ability-scores.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /**
                 * @description Search ability scores by name or code
                 * @example strength
                 */
                q?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: string[];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.ability-scores.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ability score (by ID, code, or name) */
                abilityScore: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `AbilityScoreResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["AbilityScoreResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.ability-scores.spells": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ability score (by ID, code, or name) */
                abilityScore: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `SpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SpellResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.alignments.index": {
        parameters: {
            query?: {
                /**
                 * @description Search by alignment name (partial match)
                 * @example good
                 */
                q?: unknown;
                /**
                 * @description Results per page, 1-100
                 * @example 50
                 */
                per_page?: unknown;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: {
                            slug: string;
                            name: unknown;
                        }[];
                    };
                };
            };
        };
    };
    "lookups.armor-types.index": {
        parameters: {
            query?: {
                /**
                 * @description Search armor types by name
                 * @example plate
                 */
                q?: unknown;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: {
                            slug: string;
                            name: unknown;
                        }[];
                    };
                };
            };
        };
    };
    "auth.login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoginRequest"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        token: string;
                        user: {
                            id: string;
                            name: string;
                            email: string;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "auth.register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RegisterRequest"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        token: string;
                        user: {
                            id: number;
                            name: string;
                            email: string;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "auth.logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @enum {string} */
                        message: "Logged out successfully";
                    };
                };
            };
            401: components["responses"]["AuthenticationException"];
        };
    };
    "backgrounds.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /** @description Sorting */
                sort_by?: "name" | "slug";
                sort_direction?: "asc" | "desc";
                /** @description Full-text search query */
                q?: string;
                /**
                 * @description Meilisearch filter expression. Integer fields (=,!=,>,>=,<,<=): id. String fields (=,!=): name, slug. Boolean fields (=,!=,IS NULL): grants_language_choice. Array fields (IN,NOT IN,IS EMPTY): source_codes, tag_slugs, skill_proficiencies, tool_proficiency_types. See docs/MEILISEARCH-FILTER-OPERATORS.md for details.
                 * @example skill_proficiencies IN [Insight, Religion] AND source_codes IN [PHB]
                 */
                filter?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `BackgroundResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["BackgroundResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "backgrounds.show": {
        parameters: {
            query?: {
                "include[]"?: "sources" | "sources.source" | "traits" | "traits.dataTables" | "traits.dataTables.entries" | "proficiencies" | "proficiencies.skill" | "proficiencies.proficiencyType" | "languages" | "languages.language";
                "fields[]"?: "id" | "name" | "slug" | "description" | "created_at" | "updated_at";
            };
            header?: never;
            path: {
                /** @description The background ID */
                background: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `BackgroundResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["BackgroundResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "characters.index": {
        parameters: {
            query?: {
                per_page?: number;
                page?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `CharacterResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "characters.store": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CharacterStoreRequest"];
            };
        };
        responses: {
            /** @description `CharacterResource` */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterResource"];
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "characters.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `CharacterResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "characters.update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["CharacterUpdateRequest"];
            };
        };
        responses: {
            /** @description `CharacterResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "characters.destroy": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "characters.stats": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `CharacterStatsResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterStatsResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "characters.equipment.index": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `CharacterEquipmentResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterEquipmentResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "characters.equipment.store": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StoreEquipmentRequest"];
            };
        };
        responses: {
            /** @description `CharacterEquipmentResource` */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterEquipmentResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "characters.equipment.destroy": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
                /** @description The equipment ID */
                equipment: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "characters.equipment.update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
                /** @description The equipment ID */
                equipment: number;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["UpdateEquipmentRequest"];
            };
        };
        responses: {
            /** @description `CharacterEquipmentResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterEquipmentResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "characters.level-up": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": 200;
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "characters.spells.index": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `CharacterSpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterSpellResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "characters.spells.store": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    spell_id: number;
                    /** @enum {string} */
                    source?: "class" | "race" | "feat" | "item" | "other";
                };
            };
        };
        responses: {
            /** @description `CharacterSpellResource` */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterSpellResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "characters.spells.available": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `SpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SpellResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "characters.spells.destroy": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
                /** @description The spell ID */
                spell: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "characters.spells.prepare": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
                /** @description The spell ID */
                spell: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `CharacterSpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterSpellResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "characters.spells.unprepare": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
                /** @description The spell ID */
                spell: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `CharacterSpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["CharacterSpellResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "characters.spell-slots": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The character ID */
                character: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: unknown[];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "classes.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /** @description Sorting */
                sort_by?: "name" | "hit_die" | "slug";
                sort_direction?: "asc" | "desc";
                /** @description Search query (Scout/Meilisearch) */
                q?: string;
                /**
                 * @description Meilisearch filter expression. Supports all operators by data type: Integer (=,!=,>,>=,<,<=,TO), String (=,!=), Boolean (=,!=,IS NULL,EXISTS), Array (IN,NOT IN,IS EMPTY). Fields: id, slug, hit_die, spell_count, max_spell_level, optional_feature_count, primary_ability, spellcasting_ability, parent_class_name, is_base_class, is_subclass, has_spells, is_spellcaster, has_optional_features, source_codes, tag_slugs, saving_throw_proficiencies, armor_proficiencies, weapon_proficiencies, tool_proficiencies, skill_proficiencies, optional_feature_types. See docs/MEILISEARCH-FILTER-OPERATORS.md for details.
                 * @example is_base_class = true AND armor_proficiencies IN ["Heavy Armor"]
                 */
                filter?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `ClassResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ClassResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "classes.show": {
        parameters: {
            query?: {
                "include[]"?: "sources" | "sources.source" | "features" | "features.dataTables" | "features.dataTables.entries" | "proficiencies" | "proficiencies.skill" | "proficiencies.proficiencyType" | "levelProgression" | "counters" | "spellcastingAbility";
                "fields[]"?: "id" | "name" | "slug" | "description" | "hit_die" | "created_at" | "updated_at";
                include_base_features?: boolean;
            };
            header?: never;
            path: {
                /** @description The class ID */
                class: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `ClassResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ClassResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "classes.spells": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /** @description Search */
                search?: string;
                /** @description Spell filters */
                level?: number;
                school?: number;
                concentration?: boolean;
                ritual?: boolean;
                /** @description Sorting (spells table doesn't have timestamps) */
                sort_by?: "name" | "level";
                sort_direction?: "asc" | "desc";
            };
            header?: never;
            path: {
                /** @description The class ID */
                class: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `SpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SpellResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "classes.progression": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The class ID */
                class: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: {
                            columns: {
                                key: string;
                                label: string;
                                type: string;
                            }[];
                            rows: {
                                [key: string]: unknown;
                            }[];
                        };
                    } | {
                        data: {
                            columns: string[];
                            rows: string[];
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.conditions.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /**
                 * @description Search by name
                 * @example frightened
                 */
                q?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: string[];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.conditions.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The condition ID */
                condition: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `ConditionResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ConditionResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.conditions.spells": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The condition (by ID or slug) */
                condition: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `SpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SpellResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.conditions.monsters": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The condition (by ID or slug) */
                condition: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `MonsterResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["MonsterResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.damage-types.spells": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The damage type (by ID, code, or name) */
                damageType: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `SpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SpellResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.damage-types.items": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The damage type (by ID, code, or name) */
                damageType: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `ItemResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ItemResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.damage-types.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /**
                 * @description Search damage types by name
                 * @example fire
                 */
                q?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: string[];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.damage-types.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The damage type ID */
                damageType: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `DamageTypeResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["DamageTypeResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "feats.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /** @description Sorting */
                sort_by?: "name" | "slug";
                sort_direction?: "asc" | "desc";
                /** @description Full-text search query */
                q?: string;
                /**
                 * @description Meilisearch filter expression. Supports all operators by data type: Integer (=,!=,>,>=,<,<=,TO), String (=,!=), Boolean (=,!=,IS NULL,EXISTS), Array (IN,NOT IN,IS EMPTY). Filterable fields: id, slug, source_codes, tag_slugs, has_prerequisites, grants_proficiencies, is_half_feat, improved_abilities, prerequisite_types, parent_feat_slug. See docs/MEILISEARCH-FILTER-OPERATORS.md for details.
                 * @example is_half_feat = true AND improved_abilities IN [STR]
                 */
                filter?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `FeatResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["FeatResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "feats.show": {
        parameters: {
            query?: {
                "include[]"?: "tags" | "sources" | "sources.source" | "modifiers" | "modifiers.abilityScore" | "modifiers.skill" | "proficiencies" | "proficiencies.skill" | "proficiencies.proficiencyType" | "conditions" | "prerequisites" | "prerequisites.prerequisite";
                "fields[]"?: "id" | "name" | "slug" | "description" | "prerequisites_text" | "created_at" | "updated_at";
            };
            header?: never;
            path: {
                /** @description The feat ID */
                feat: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `FeatResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["FeatResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "items.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /** @description Sorting */
                sort_by?: "name" | "type" | "rarity" | "slug";
                sort_direction?: "asc" | "desc";
                /** @description Search query (Scout/Meilisearch) */
                q?: string;
                /**
                 * @description Meilisearch filter expression. Supports all operators by data type: Integer (=,!=,>,>=,<,<=,TO), String (=,!=), Boolean (=,!=,IS NULL,EXISTS), Array (IN,NOT IN,IS EMPTY). Filterable fields: id, slug, type_name, type_code, rarity, requires_attunement, is_magic, weight, cost_cp, source_codes, damage_dice, versatile_damage, damage_type, range_normal, range_long, armor_class, strength_requirement, stealth_disadvantage, charges_max, has_charges, recharge_timing, recharge_formula, spell_slugs, tag_slugs, property_codes, modifier_categories, proficiency_names, saving_throw_abilities, has_prerequisites, proficiency_category, magic_bonus. See docs/MEILISEARCH-FILTER-OPERATORS.md for details.
                 * @example proficiency_category = martial_melee AND magic_bonus >= 1
                 */
                filter?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `ItemResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ItemResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "items.show": {
        parameters: {
            query?: {
                "include[]"?: "sources" | "sources.source" | "modifiers" | "abilities" | "prerequisites" | "prerequisites.prerequisite" | "spells" | "spells.spellSchool" | "tags" | "savingThrows";
                "fields[]"?: "id" | "name" | "slug" | "type" | "rarity" | "description" | "magic" | "attunement" | "strength_requirement" | "created_at" | "updated_at" | "item_type_id" | "detail" | "cost_cp" | "weight" | "damage_dice" | "versatile_damage" | "damage_type_id" | "range_normal" | "range_long" | "armor_class" | "stealth_disadvantage" | "charges_max" | "recharge_formula" | "recharge_timing";
            };
            header?: never;
            path: {
                /** @description The item ID */
                item: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `ItemResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ItemResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.item-properties.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /**
                 * @description Search properties by name
                 * @example finesse
                 */
                q?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `ItemPropertyResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ItemPropertyResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.item-properties.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The item property ID */
                itemProperty: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `ItemPropertyResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ItemPropertyResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.item-types.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /**
                 * @description Search item types by name
                 * @example weapon
                 */
                q?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `ItemTypeResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ItemTypeResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.item-types.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The item type ID */
                itemType: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `ItemTypeResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ItemTypeResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.languages.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /**
                 * @description Search by name
                 * @example elvish
                 */
                q?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: string[];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.languages.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The language ID */
                language: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `LanguageResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["LanguageResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.languages.races": {
        parameters: {
            query?: {
                per_page?: number;
            };
            header?: never;
            path: {
                /** @description The language ID */
                language: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `RaceResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["RaceResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.languages.backgrounds": {
        parameters: {
            query?: {
                per_page?: number;
            };
            header?: never;
            path: {
                /** @description The language ID */
                language: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `BackgroundResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["BackgroundResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "monsters.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /** @description Sorting */
                sort_by?: "name" | "challenge_rating" | "hit_points_average" | "armor_class" | "experience_points";
                sort_direction?: "asc" | "desc";
                /** @description Full-text search query */
                q?: string;
                /**
                 * @description Meilisearch filter expression. Supports all operators by data type: Integer (=,!=,>,>=,<,<=,TO), String (=,!=), Boolean (=,!=,IS NULL,EXISTS), Array (IN,NOT IN,IS EMPTY). Fields: challenge_rating, armor_class, hit_points_average, experience_points, strength, dexterity, constitution, intelligence, wisdom, charisma, speed_walk, speed_fly, speed_swim, speed_burrow, speed_climb, passive_perception, legendary_resistance_uses, type, size_code, size_name, alignment, armor_type, slug, has_legendary_actions, has_lair_actions, is_spellcaster, has_reactions, has_legendary_resistance, has_magic_resistance, can_hover, is_npc, source_codes, tag_slugs, spell_slugs. See docs/MEILISEARCH-FILTER-OPERATORS.md for details.
                 * @example challenge_rating >= 10 AND has_legendary_actions = true
                 */
                filter?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `MonsterResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["MonsterResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "monsters.show": {
        parameters: {
            query?: {
                "include[]"?: "size" | "traits" | "actions" | "legendaryActions" | "spellcasting" | "sources" | "sources.source" | "modifiers" | "modifiers.abilityScore" | "modifiers.skill" | "modifiers.damageType" | "conditions";
                "fields[]"?: "id" | "name" | "slug" | "size_id" | "type" | "alignment" | "armor_class" | "armor_type" | "hit_points_average" | "hit_dice" | "speed_walk" | "speed_fly" | "speed_swim" | "speed_burrow" | "speed_climb" | "can_hover" | "strength" | "dexterity" | "constitution" | "intelligence" | "wisdom" | "charisma" | "challenge_rating" | "experience_points" | "description";
            };
            header?: never;
            path: {
                /** @description The monster ID */
                monster: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `MonsterResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["MonsterResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "monsters.spells": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The monster ID */
                monster: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `SpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SpellResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.monster-types.index": {
        parameters: {
            query?: {
                /**
                 * @description Search creature types by name
                 * @example fiend
                 */
                q?: unknown;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: {
                            slug: string;
                            name: unknown;
                        }[];
                    };
                };
            };
        };
    };
    "optional-features.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /** @description Sorting */
                sort_by?: "name" | "level_requirement" | "resource_cost" | "slug";
                sort_direction?: "asc" | "desc";
                /** @description Full-text search query */
                q?: string;
                /**
                 * @description Meilisearch filter expression. Supports all operators by data type: Integer (=,!=,>,>=,<,<=,TO), String (=,!=), Boolean (=,!=,IS NULL,EXISTS), Array (IN,NOT IN,IS EMPTY). See docs/MEILISEARCH-FILTER-OPERATORS.md for details.
                 * @example feature_type = eldritch_invocation AND level_requirement <= 5
                 */
                filter?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `OptionalFeatureResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["OptionalFeatureResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "optional-features.show": {
        parameters: {
            query?: {
                "include[]"?: string[];
            };
            header?: never;
            path: {
                /** @description The optional feature slug */
                optionalFeature: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `OptionalFeatureResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["OptionalFeatureResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.optional-feature-types.index": {
        parameters: {
            query?: {
                /**
                 * @description Search optional feature types by name
                 * @example fighting
                 */
                q?: unknown;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: {
                            value: string;
                            label: string;
                            default_class: null | ("Warlock" | "Monk" | "Fighter" | "Sorcerer" | "Artificer");
                            default_subclass: null | ("Way of the Four Elements" | "Battle Master" | "Rune Knight" | "Arcane Archer");
                        }[];
                    };
                };
            };
        };
    };
    "lookups.proficiency-types.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /**
                 * @description Search proficiencies by name
                 * @example longsword
                 */
                q?: string;
                /**
                 * @description Filter by category (weapon, armor, tool, language, skill, saving-throw)
                 * @example weapon
                 */
                category?: string;
                /**
                 * @description Filter by subcategory within category (e.g., simple, martial)
                 * @example martial
                 */
                subcategory?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: string[];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.proficiency-types.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The proficiency type slug */
                proficiencyType: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `ProficiencyTypeResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ProficiencyTypeResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.proficiency-types.classes": {
        parameters: {
            query?: {
                per_page?: number;
            };
            header?: never;
            path: {
                /** @description The proficiency type slug */
                proficiencyType: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `ClassResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ClassResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.proficiency-types.races": {
        parameters: {
            query?: {
                per_page?: number;
            };
            header?: never;
            path: {
                /** @description The proficiency type slug */
                proficiencyType: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `RaceResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["RaceResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.proficiency-types.backgrounds": {
        parameters: {
            query?: {
                per_page?: number;
            };
            header?: never;
            path: {
                /** @description The proficiency type slug */
                proficiencyType: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `BackgroundResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["BackgroundResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "races.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /** @description Sorting */
                sort_by?: "name" | "size" | "speed" | "slug";
                sort_direction?: "asc" | "desc";
                /** @description Full-text search query */
                q?: string;
                /**
                 * @description Meilisearch filter expression. Supports all operators by data type: Integer (=,!=,>,>=,<,<=,TO), String (=,!=), Boolean (=,!=,IS NULL,EXISTS), Array (IN,NOT IN,IS EMPTY). See docs/MEILISEARCH-FILTER-OPERATORS.md for details.
                 * @example ability_int_bonus >= 2 AND speed >= 30
                 */
                filter?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `RaceResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["RaceResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "races.show": {
        parameters: {
            query?: {
                "include[]"?: "sources" | "sources.source" | "traits" | "proficiencies" | "proficiencies.skill" | "proficiencies.proficiencyType" | "modifiers" | "languages";
                "fields[]"?: "id" | "name" | "slug" | "description" | "size" | "speed" | "created_at" | "updated_at";
            };
            header?: never;
            path: {
                /** @description The race ID */
                race: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `RaceResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["RaceResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "races.spells": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The race ID */
                race: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `SpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SpellResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.rarities.index": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: {
                            slug: string;
                            name: unknown;
                        }[];
                    };
                };
            };
        };
    };
    search: {
        parameters: {
            query: {
                q: string;
                "types[]"?: "spell" | "item" | "race" | "class" | "background" | "feat" | "monster";
                limit?: number;
                debug?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `SearchResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchResource"];
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.sizes.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /**
                 * @description Search by name
                 * @example medium
                 */
                q?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: string[];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.sizes.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The size ID */
                size: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `SizeResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SizeResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.sizes.races": {
        parameters: {
            query?: {
                per_page?: string;
            };
            header?: never;
            path: {
                /** @description The size ID */
                size: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `RaceResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["RaceResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.sizes.monsters": {
        parameters: {
            query?: {
                per_page?: string;
            };
            header?: never;
            path: {
                /** @description The size ID */
                size: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `MonsterResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["MonsterResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.skills.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /**
                 * @description Search skills by name
                 * @example perception
                 */
                q?: string;
                /**
                 * @description Filter by ability score code (STR, DEX, CON, INT, WIS, CHA)
                 * @example DEX
                 */
                ability?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `SkillResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SkillResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.skills.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The skill ID */
                skill: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `SkillResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SkillResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.sources.index": {
        parameters: {
            query?: {
                page?: number;
                /**
                 * @description Search by sourcebook name or code (e.g., "handbook", "PHB", "xanathar")
                 * @example handbook
                 */
                q?: string;
                /**
                 * @description Results per page (1-100, default: 50)
                 * @example 20
                 */
                per_page?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `SourceResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SourceResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.sources.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sourcebook to retrieve (accepts ID or code) */
                source: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `SourceResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SourceResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "spells.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /** @description Sorting */
                sort_by?: "name" | "level" | "slug";
                sort_direction?: "asc" | "desc";
                /** @description Full-text search query */
                q?: string;
                /**
                 * @description Meilisearch filter expression. Supports all operators by data type: Integer (=,!=,>,>=,<,<=,TO), String (=,!=), Boolean (=,!=,IS NULL,EXISTS), Array (IN,NOT IN,IS EMPTY). Filterable fields include: id, level, school_code, school_name, concentration, ritual, requires_verbal, requires_somatic, requires_material, class_slugs, tag_slugs, source_codes, damage_types, saving_throws, effect_types, material_cost_gp, material_consumed, aoe_type, aoe_size. See docs/MEILISEARCH-FILTER-OPERATORS.md for details.
                 * @example aoe_type = sphere AND aoe_size >= 20
                 */
                filter?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `SpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SpellResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "spells.show": {
        parameters: {
            query?: {
                "include[]"?: "spellSchool" | "sources" | "sources.source" | "effects" | "effects.damageType" | "classes" | "tags" | "savingThrows" | "dataTables" | "dataTables.entries";
                "fields[]"?: "id" | "name" | "slug" | "level" | "description" | "casting_time" | "range" | "components" | "material_components" | "duration" | "needs_concentration" | "is_ritual" | "higher_levels" | "created_at" | "updated_at";
            };
            header?: never;
            path: {
                /** @description The spell ID */
                spell: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `SpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SpellResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
            422: components["responses"]["ValidationException"];
        };
    };
    "spells.classes": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The spell to find classes for (accepts ID or slug) */
                spell: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `ClassResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ClassResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "spells.monsters": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The spell to find monsters for (accepts ID or slug) */
                spell: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `MonsterResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["MonsterResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "spells.items": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The spell to find items for (accepts ID or slug) */
                spell: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `ItemResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["ItemResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "spells.races": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The spell to find races for (accepts ID or slug) */
                spell: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `RaceResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["RaceResource"][];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.spell-schools.index": {
        parameters: {
            query?: {
                /** @description Pagination */
                per_page?: number;
                page?: number;
                /**
                 * @description Search schools by name
                 * @example evocation
                 */
                q?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: string[];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            422: components["responses"]["ValidationException"];
        };
    };
    "lookups.spell-schools.show": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The spell school ID */
                spellSchool: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description `SpellSchoolResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SpellSchoolResource"];
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.spell-schools.spells": {
        parameters: {
            query?: {
                per_page?: string;
            };
            header?: never;
            path: {
                /** @description The school of magic (by ID, code, or slug) */
                spellSchool: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paginated set of `SpellResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["SpellResource"][];
                        links: {
                            first: string | null;
                            last: string | null;
                            prev: string | null;
                            next: string | null;
                        };
                        meta: {
                            current_page: number;
                            from: number | null;
                            last_page: number;
                            /** @description Generated paginator links. */
                            links: {
                                url: string | null;
                                label: string;
                                active: boolean;
                            }[];
                            /** @description Base path for paginator generated URLs. */
                            path: string | null;
                            /** @description Number of items shown per page. */
                            per_page: number;
                            /** @description Number of the last item in the slice. */
                            to: number | null;
                            /** @description Total number of items being paginated. */
                            total: number;
                        };
                    };
                };
            };
            404: components["responses"]["ModelNotFoundException"];
        };
    };
    "lookups.tags.index": {
        parameters: {
            query?: {
                /**
                 * @description Filter tags by entity type: spell, monster, item, race, class, feat, background
                 * @example spell
                 */
                type?: unknown;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Array of `TagResource` */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data: components["schemas"]["TagResource"][];
                    };
                };
            };
        };
    };
}
